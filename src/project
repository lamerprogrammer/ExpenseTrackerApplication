//package com.example.expensetracker.config;
//
//import org.springframework.context.annotation.Bean;
//import org.springframework.context.annotation.Configuration;
//import org.springframework.web.servlet.LocaleResolver;
//import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
//import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
//import org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver;
//import org.springframework.web.servlet.i18n.LocaleChangeInterceptor;
//import org.springframework.web.servlet.i18n.SessionLocaleResolver;
//
//import java.util.List;
//import java.util.Locale;
//
//@Configuration
//public class LocaleConfig implements WebMvcConfigurer {
//
//    @Bean
//    public LocaleResolver localeResolver() {
//        SessionLocaleResolver resolver = new SessionLocaleResolver();
//        resolver.setDefaultLocale(Locale.forLanguageTag("ru"));
//        return resolver;
//    }
//
//    @Bean
//    public LocaleChangeInterceptor localeChangeInterceptor() {
//        LocaleChangeInterceptor interceptor = new LocaleChangeInterceptor();
//        interceptor.setParamName("lang");
//        return interceptor;
//    }
//
//    @Override
//    public void addInterceptors(InterceptorRegistry registry) {
//        registry.addInterceptor(localeChangeInterceptor());
//    }
//}
//

package com.example.expensetracker.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;

/**
 * –ö–ª–∞—Å—Å —Å–æ–∑–¥–∞–Ω –¥–ª—è —Ä–∞–±–æ—Ç—ã —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ @PreAuthorize("hasRole('ADMIN')") –∏ –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã—Ö. 
 */
@Configuration
@EnableMethodSecurity
public class MethodSecurityConfig {
}

package com.example.expensetracker.config;

import com.example.expensetracker.security.CustomAccessDeniedHandler;
import com.example.expensetracker.security.CustomAuthEntryPoint;
import com.example.expensetracker.security.JwtAuthFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
public class SecurityConfig {

    private final JwtAuthFilter jwtAuthFilter;
    private final CustomAuthEntryPoint customAuthEntryPoint;
    private final CustomAccessDeniedHandler customAccessDeniedHandler;

    public SecurityConfig(JwtAuthFilter jwtAuthFilter, CustomAuthEntryPoint customAuthEntryPoint,
                          CustomAccessDeniedHandler customAccessDeniedHandler) {
        this.jwtAuthFilter = jwtAuthFilter;
        this.customAuthEntryPoint = customAuthEntryPoint;
        this.customAccessDeniedHandler = customAccessDeniedHandler;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers(
                                "/api/auth/register",
                                "/api/auth/login",
                                "/api/auth/refresh",
                                "/swagger-ui/**",
                                "/v3/api-docs/**",
                                "/swagger-ui.html",
                                "/webjars/**").permitAll()
                        .requestMatchers("/api/users/me").hasAnyRole("USER", "MODERATOR", "ADMIN")
                        .requestMatchers("/api/mod/**").hasRole("MODERATOR")
                        .requestMatchers("/api/admin/**").hasRole("ADMIN")
                        .anyRequest().authenticated())
                .exceptionHandling(e -> e
                        .authenticationEntryPoint(customAuthEntryPoint)
                        .accessDeniedHandler(customAccessDeniedHandler))
                .sessionManagement(sm ->
                        sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}

package com.example.expensetracker.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI expenseTrackerOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Expense Tracker API")
                        .version("1.0"))
                .addSecurityItem(new SecurityRequirement().addList("Bearer Authentication"))
                .components(new io.swagger.v3.oas.models.Components()
                        .addSecuritySchemes("Bearer Authentication",
                                new SecurityScheme()
                                        .name("Authorization")
                                        .type(SecurityScheme.Type.HTTP)
                                        .scheme("bearer")
                                        .bearerFormat("JWT")));
    }
}

package com.example.expensetracker.config;

import io.swagger.v3.oas.models.Operation;
import io.swagger.v3.oas.models.tags.Tag;
import org.springdoc.core.customizers.OpenApiCustomizer;
import org.springdoc.core.service.OpenAPIService;
import org.springframework.context.MessageSource;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.util.StringUtils;

import java.util.Locale;
import java.util.Optional;

@Configuration
public class SwaggerI18nConfig {

    private final MessageSource messageSource;
    private final OpenAPIService openAPIService;

    public SwaggerI18nConfig(MessageSource messageSource, OpenAPIService openAPIService) {
        this.messageSource = messageSource;
        this.openAPIService = openAPIService;
    }

    @Bean
    public OpenApiCustomizer localizedOpenApiCustomizer() {
        return openApi -> {
            Locale locale = LocaleContextHolder.getLocale();
            if (openApi.getTags() != null) {
                openApi.setTags(openApi.getTags().stream()
                        .map(tag -> localizeTag(tag, locale))
                        .toList());
            }
            if (openApi.getPaths() != null) {
                openApi.getPaths().values()
                        .forEach(path -> path.readOperations()
                                .forEach(op -> localizeOperation(op, locale)));
            }
        };
    }

    private void localizeOperation(Operation operation, Locale locale) {
        Optional.ofNullable(operation.getSummary())
                .filter(StringUtils::hasText)
                .ifPresent(summary -> operation.setSummary(resolve(summary, locale)));
        Optional.ofNullable(operation.getDescription())
                .filter(StringUtils::hasText)
                .ifPresent(desc -> operation.setDescription(resolve(desc, locale)));
    }

    private Tag localizeTag(Tag tag, Locale locale) {
        Optional.ofNullable(tag.getName())
                .filter(StringUtils::hasText)
                .ifPresent(name -> tag.setName(resolve(name, locale)));

        Optional.ofNullable(tag.getDescription())
                .filter(StringUtils::hasText)
                .ifPresent(desc -> tag.setDescription(resolve(desc, locale)));

        return tag;
    }

    private String resolve(String code, Locale locale) {
        try {
            return messageSource.getMessage(code, null, code, locale);
        } catch (Exception e) {
            return code;
        }
    }

    /**
     * üöÄ –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ —Å–º–µ–Ω–µ –ª–æ–∫–∞–ª–∏ (—á–µ—Ä–µ–∑ ?lang=ru / ?lang=en).
     * –û—á–∏—â–∞–µ—Ç –∫—ç—à OpenAPIService, —á—Ç–æ–±—ã Swagger –ø–µ—Ä–µ—Å–æ–±—Ä–∞–ª JSON.
     */
    @Bean
    public LocaleChangeInterceptorCustomizer localeChangeInterceptorCustomizer() {
        return new LocaleChangeInterceptorCustomizer(openAPIService);
    }
}

package com.example.expensetracker.details;

import com.example.expensetracker.model.User;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.security.Principal;
import java.util.Collection;
import java.util.List;

public class UserDetailsImpl implements UserDetails, Principal {

    private final User user;

    public UserDetailsImpl(User user) {
        this.user = user;
    }

    public User getDomainUser() {
        return user;
    }

    @Override
    public String getName() {
        return user.getEmail();
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return user.getRoles().stream()
                .map(role -> new SimpleGrantedAuthority("ROLE_" + role.name()))
                .toList();
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getEmail();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return !user.isBanned();
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return !user.isBanned();
    }
}

package com.example.expensetracker.dto;

import com.example.expensetracker.model.Role;
import com.example.expensetracker.model.User;
import com.fasterxml.jackson.annotation.JsonProperty;

import java.math.BigDecimal;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class AdminUserDto {

    private final Long id;

    private final String email;

    private Set<Role> roles = new HashSet<>();

    private boolean banned = false;

    private boolean deleted = false;

    private BigDecimal totalExpenses = BigDecimal.ZERO;
    
    public AdminUserDto(@JsonProperty("id") Long id,
                        @JsonProperty("email") String email,
                        @JsonProperty("roles") Set<Role> roles,
                        @JsonProperty("banned") boolean banned,
                        @JsonProperty("deleted") boolean deleted,
                        @JsonProperty("totalExpenses") BigDecimal totalExpenses) {
        this.id = id;
        this.email = email;
        this.roles = roles;
        this.banned = banned;
        this.deleted = deleted;
        this.totalExpenses = totalExpenses;
    }

    public String getEmail() {
        return email;
    }

    public Long getId() {
        return id;
    }

    public Set<Role> getRoles() {
        return roles;
    }

    public boolean isBanned() {
        return banned;
    }

    public boolean isDeleted() {
        return deleted;
    }

    public BigDecimal getTotalExpenses() {
        return totalExpenses;
    }

    public static AdminUserDto fromEntity(User user) {
        return new AdminUserDto(user.getId(), user.getEmail(), user.getRoles(), user.isBanned(),
                user.isDeleted(), user.getTotalExpenses());
    }

    public static List<AdminUserDto> fromEntities(List<User> users) {
        return users.stream()
                .map(user -> new AdminUserDto(user.getId(), user.getEmail(), user.getRoles(), user.isBanned(),
                        user.isDeleted(), user.getTotalExpenses()))
                .collect(Collectors.toList());
    }
}

package com.example.expensetracker.dto;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

import java.time.Instant;
import java.util.List;

public class ApiResponse<T> {

    private final Instant timestamp;
    private final int status;
    private final String error;
    private final String message;
    private final String path;
    private final T data;
    private final List<String> errors;

    @JsonCreator
    public ApiResponse(@JsonProperty("timestamp") Instant timestamp,
                       @JsonProperty("status") int status,
                       @JsonProperty("error") String error,
                       @JsonProperty("message") String message,
                       @JsonProperty("path") String path,
                       @JsonProperty("data") T data,
                       @JsonProperty("errors") List<String> errors) {
        this.timestamp = timestamp;
        this.status = status;
        this.error = error;
        this.message = message;
        this.path = path;
        this.data = data;
        this.errors = errors;
    }

    public Instant getTimestamp() {
        return timestamp;
    }

    public int getStatus() {
        return status;
    }

    public String getError() {
        return error;
    }

    public String getMessage() {
        return message;
    }

    public String getPath() {
        return path;
    }

    public T getData() {
        return data;
    }

    public List<String> getErrors() {
        return errors;
    }
}

package com.example.expensetracker.dto;

import jakarta.servlet.http.HttpServletRequest;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import java.time.Instant;
import java.util.List;

public class ApiResponseFactory {

    private ApiResponseFactory() {}

    public static <T> ApiResponse<T> success(T data, String message, HttpServletRequest request) {
        return new ApiResponse<>(
                Instant.now(),
                HttpStatus.OK.value(),
                null,
                message,
                request.getRequestURI(),
                data,
                null);
    }

    public static <T> ResponseEntity<ApiResponse<T>> error(HttpStatus status, String error, String message,
                                                           HttpServletRequest request) {
        return ResponseEntity.status(status).body(
                new ApiResponse<>(
                        Instant.now(),
                        status.value(),
                        error,
                        message,
                        request.getRequestURI(),
                        null,
                        null));
    }

    public static <T> ResponseEntity<ApiResponse<T>> validationError(HttpStatus status, String message,
                                                           HttpServletRequest request, List<String> errors) {
        return ResponseEntity.status(status).body(
                new ApiResponse<>(
                        Instant.now(),
                        status.value(),
                        "ValidationError",
                        message,
                        request.getRequestURI(),
                        null,
                        errors));
    }

    public static ApiResponse<?> unauthorized(HttpServletRequest request) {
        return new ApiResponse<>(
                Instant.now(),
                HttpStatus.UNAUTHORIZED.value(),
                HttpStatus.UNAUTHORIZED.getReasonPhrase(),
                "–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω: —Ç—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è",
                request.getRequestURI(),
                null,
                null
        );
    }

    public static ApiResponse<?> forbidden(HttpServletRequest request) {
        return new ApiResponse<>(
                Instant.now(),
                HttpStatus.FORBIDDEN.value(),
                HttpStatus.FORBIDDEN.getReasonPhrase(),
                "–£ –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É —Ä–µ—Å—É—Ä—Å—É",
                request.getRequestURI(),
                null,
                null
        );
    }
}

package com.example.expensetracker.dto;

public class AuthResponse {

    private  String token;
    private  String email;
    private  String role;

    public AuthResponse(String token, String email, String role) {
        this.token = token;
        this.email = email;
        this.role = role;
    }

    public String getToken() {
        return token;
    }

    public String getEmail() {
        return email;
    }

    public String getRole() {
        return role;
    }
}

package com.example.expensetracker.dto;

import java.math.BigDecimal;

public record CategorySumDto(String categoryName, BigDecimal sum) {
}

package com.example.expensetracker.dto;

import jakarta.validation.constraints.NotBlank;

public record ChangePasswordRequest(
        @NotBlank(message = "{change.password.request.old.not-blank}")
        String oldPassword,
        
        @NotBlank(message = "{change.password.request.new.not-blank}")
        String newPassword
) {}

package com.example.expensetracker.dto;

import jakarta.validation.constraints.AssertTrue;
import jakarta.validation.constraints.NotNull;

import java.time.Instant;

public class DateRangeDto {
    
    @NotNull(message = "{date.range.dto.from.not.null}")
    private Instant from;
    
    @NotNull(message = "{date.range.dto.to.not.null}")
    private Instant to;
    
    @AssertTrue(message = "{date.range.dto.from.is.valid.range}")
    public boolean isValidRange() {
        return from != null && to != null && from.isBefore(to);
    }

    public Instant getFrom() {
        return from;
    }

    public void setFrom(Instant from) {
        this.from = from;
    }

    public Instant getTo() {
        return to;
    }

    public void setTo(Instant to) {
        this.to = to;
    }
}

package com.example.expensetracker.dto;

import java.math.BigDecimal;
import java.util.List;

public record ExpensesReportDto(BigDecimal total, List<CategorySumDto> byCategory) {
}

package com.example.expensetracker.dto;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

import java.util.Objects;

public final class LoginDto {

    @Email(message = "{user.email.invalid}")
    @NotBlank(message = "{user.email.not-blank}")
    private final String email;

    @NotBlank(message = "{user.password.not-blank}")
    private final String password;

    @JsonCreator
    public LoginDto(@JsonProperty("email") String email,
                    @JsonProperty("password") String password) {
        this.email = email;
        this.password = password;
    }

    public String getEmail() {
        return email;
    }

    public String getPassword() {
        return password;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        LoginDto loginDto = (LoginDto) o;
        return Objects.equals(email, loginDto.email) && Objects.equals(password, loginDto.password);
    }

    @Override
    public int hashCode() {
        return Objects.hash(email, password);
    }

    @Override
    public String toString() {
        return "LoginDto{" +
                "email='" + email + '\'' +
                ", password=****}";
    }
}

package com.example.expensetracker.dto;

public record LoginRequest(String email,  String password) {}

package com.example.expensetracker.dto;

import com.example.expensetracker.model.Role;
import com.example.expensetracker.model.User;
import com.fasterxml.jackson.annotation.JsonProperty;

import java.math.BigDecimal;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class ModeratorUserDto {

    private final Long id;

    private final String email;

    private Set<Role> roles = new HashSet<>();

    private boolean banned = false;

    private BigDecimal totalExpenses = BigDecimal.ZERO;

    public ModeratorUserDto(@JsonProperty("id") Long id,
                            @JsonProperty("email") String email,
                            @JsonProperty("roles") Set<Role> roles,
                            @JsonProperty("banned") boolean banned,
                            @JsonProperty("totalExpenses") BigDecimal totalExpenses) {
        this.id = id;
        this.email = email;
        this.roles = roles;
        this.banned = banned;
        this.totalExpenses = totalExpenses;
    }

    public String getEmail() {
        return email;
    }

    public Long getId() {
        return id;
    }

    public Set<Role> getRoles() {
        return roles;
    }

    public boolean isBanned() {
        return banned;
    }

    public BigDecimal getTotalExpenses() {
        return totalExpenses;
    }

    public static ModeratorUserDto fromEntity(User user) {
        return new ModeratorUserDto(user.getId(), user.getEmail(), user.getRoles(), user.isBanned(),
                user.getTotalExpenses());
    }

    public static List<ModeratorUserDto> fromEntities(List<User> users) {
        return users.stream()
                .map(user -> new ModeratorUserDto(user.getId(), user.getEmail(), user.getRoles(), user.isBanned(),
                        user.getTotalExpenses()))
                .collect(Collectors.toList());
    }
}

package com.example.expensetracker.dto;

import java.math.BigDecimal;
import java.time.LocalDate;

public final class RecurringTransactionDto {

    private final Long id;

    private final BigDecimal amount;

    private final String description;

    private final Long categoryId;

    private final String categoryName;

    private final int intervalDays;

    private final LocalDate nextExecutionDate;

    private final boolean active;

    public RecurringTransactionDto(Long id, BigDecimal amount, String description, Long categoryId,
                                   String categoryName, int intervalDays, LocalDate nextExecutionDate, boolean active) {
        if (amount == null || description == null || categoryId == null || nextExecutionDate == null) {
            throw new IllegalArgumentException("RecurringTransactionDto: mandatory field is null");
        }
        this.id = id;
        this.amount = amount;
        this.description = description;
        this.categoryId = categoryId;
        this.categoryName = categoryName;
        this.intervalDays = intervalDays;
        this.nextExecutionDate = nextExecutionDate;
        this.active = active;
    }

    public Long getId() {
        return id;
    }

    public BigDecimal getAmount() {
        return amount;
    }

    public String getDescription() {
        return description;
    }

    public Long getCategoryId() {
        return categoryId;
    }

    public String getCategoryName() {
        return categoryName;
    }

    public int getIntervalDays() {
        return intervalDays;
    }

    public LocalDate getNextExecutionDate() {
        return nextExecutionDate;
    }

    public boolean isActive() {
        return active;
    }
}

package com.example.expensetracker.dto;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;

import java.math.BigDecimal;

public record RecurringTransactionRequestDto(
        @NotNull(message = "{recurring.transaction.request.amount.not.null}")
        @Positive(message = "{recurring.transaction.request.amount.positive}")
        BigDecimal amount,
        
        @NotBlank(message = "{recurring.transaction.request.description.not.blank}")
        String description,
        
        @NotNull(message = "{recurring.transaction.request.category.id.not.null}")
        Long categoryId,
        
        @Min(1)
        int intervalDays
) {
}

package com.example.expensetracker.dto;

public record RefreshRequest(String refreshToken) {}

package com.example.expensetracker.dto;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

import java.util.Objects;

public final class RegisterDto {

    @NotBlank(message = "{user.name.not-blank}")
    private final String name;

    @Email(message = "{user.email.invalid}")
    @NotBlank(message = "{user.email.not-blank}")
    private final String email;

    @NotBlank(message = "{user.password.not-blank}")
    private final String password;

    @JsonCreator
    public RegisterDto(@JsonProperty("name") String name,
                       @JsonProperty("email") String email,
                       @JsonProperty("password") String password) {
        this.name = name;
        this.email = email;
        this.password = password;
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

    public String getPassword() {
        return password;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        RegisterDto that = (RegisterDto) o;
        return Objects.equals(name, that.name) &&
                Objects.equals(email, that.email) &&
                Objects.equals(password, that.password);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, email, password);
    }

    @Override
    public String toString() {
        return "RegisterDto{" +
                "name='" + name + '\'' +
                ", email='" + email + '\'' +
                ", password=****}";
    }
}

package com.example.expensetracker.dto;

public record TokenResponse(String accessToken, String refreshToken) {}

package com.example.expensetracker.dto;

import com.example.expensetracker.model.User;
import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

import java.util.List;
import java.util.stream.Collectors;

public final class UserDto {
    
    private final Long id;

    private final String email;

    public UserDto(@JsonProperty("id") Long id,
                   @JsonProperty("email") String email) {
        this.id = id;
        this.email = email;
    }

    public String getEmail() {
        return email;
    }

    public Long getId() {
        return id;
    }
    
    public static UserDto fromEntity(User user) {
        return new UserDto(user.getId(), user.getEmail());
    }

    public static List<UserDto> fromEntities(List<User> users) {
        return users.stream()
                .map(user -> new UserDto(user.getId(), user.getEmail()))
                .collect(Collectors.toList());
    }
}

package com.example.expensetracker.exception;

import com.example.expensetracker.dto.ApiResponse;
import com.example.expensetracker.dto.ApiResponseFactory;
import com.example.expensetracker.dto.UserDto;
import com.example.expensetracker.logging.applog.AppLogDto;
import com.example.expensetracker.logging.applog.AppLogLevel;
import com.example.expensetracker.logging.applog.AppLogService;
import jakarta.persistence.EntityExistsException;
import jakarta.persistence.EntityNotFoundException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.ConstraintViolationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.MissingServletRequestParameterException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.HandlerMethodValidationException;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.time.Instant;
import java.util.List;
import java.util.Objects;

@RestControllerAdvice
public class GlobalExceptionHandler {

    private final static Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    private final MessageSource messageSource;
    private final AppLogService appLogService;

    public GlobalExceptionHandler(MessageSource messageSource, AppLogService appLogService) {
        this.messageSource = messageSource;
        this.appLogService = appLogService;
    }

    @ExceptionHandler(BadCredentialsException.class)
    public ResponseEntity<ApiResponse<UserDto>> handleBadCredentials(BadCredentialsException ex, 
                                                                     HttpServletRequest request) {
        return buildResponse(HttpStatus.UNAUTHORIZED, msg("handle.bad.credentials"), request, ex);
    }

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ApiResponse<UserDto>> handleAccessDenied(AccessDeniedException ex, 
                                                                   HttpServletRequest request) {
        return buildResponse(HttpStatus.FORBIDDEN, msg("handle.access.denied"), request, ex);
    }

    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<ApiResponse<UserDto>> handleEntityNotFound(EntityNotFoundException ex, 
                                                                     HttpServletRequest request) {
        return buildResponse(HttpStatus.NOT_FOUND, msg("handle.entity.not.found"), request, ex);
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ApiResponse<UserDto>> handleDataIntegrityViolation(DataIntegrityViolationException ex, 
                                                                             HttpServletRequest request) {
        return buildResponse(HttpStatus.CONFLICT, msg("handle.data.integrity.violation"), request, ex);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ApiResponse<UserDto>> handleIllegalArgument(IllegalArgumentException ex, 
                                                                      HttpServletRequest request) {
        return buildResponse(HttpStatus.BAD_REQUEST, msg("handle.illegal.argument"), request, ex);
    }

    @ExceptionHandler(UsernameNotFoundException.class)
    public ResponseEntity<ApiResponse<UserDto>> handleUsernameNotFound(UsernameNotFoundException ex, 
                                                                       HttpServletRequest request) {
        return buildResponse(HttpStatus.UNAUTHORIZED, msg("handle.username.not.found"), request, ex);
    }

    @ExceptionHandler(UserNotFoundByIdException.class)
    public ResponseEntity<ApiResponse<UserDto>> handleUserNotFoundById(UserNotFoundByIdException ex, 
                                                                       HttpServletRequest request) {
        return buildResponse(HttpStatus.NOT_FOUND, msg("handle.user.not.found.by.id"), request, ex);
    }
    
    @ExceptionHandler(EntityExistsException.class)
    public ResponseEntity<ApiResponse<UserDto>> handleEntityExists(EntityExistsException ex,
                                                                   HttpServletRequest request) {
        return buildResponse(HttpStatus.CONFLICT, msg("handle.entity.exists"), request, ex);
    }

    @ExceptionHandler(HandlerMethodValidationException.class)
    public ResponseEntity<ApiResponse<UserDto>> handleHandlerMethodValidation(HandlerMethodValidationException ex,
                                                                   HttpServletRequest request) {
        return buildResponse(HttpStatus.BAD_REQUEST, msg("handle.handler.method.validation"), request, ex);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<UserDto>> handleMethodArgumentNotValid(MethodArgumentNotValidException ex,
                                                                    HttpServletRequest request) {
        List<String> errors = ex.getBindingResult().getFieldErrors().stream()
                .map(error -> Objects.requireNonNullElse(error.getDefaultMessage(),
                        msg("handle.validation.error")))
                .toList();
        String message = errors.isEmpty() ? msg("handle.validation.error") : String.join(". ", errors);
        
        log.warn("Validation error: user={} path={} errors={}",
                request.getUserPrincipal() != null ? request.getUserPrincipal().getName() : "anonymous",
                request.getRequestURI(),
                errors);
        return ApiResponseFactory.validationError(HttpStatus.BAD_REQUEST, message, request, errors);
    }

    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity<ApiResponse<UserDto>> handleConstraintViolation(ConstraintViolationException ex,
                                                                             HttpServletRequest request) {
        List<String> errors = ex.getConstraintViolations().stream()
                .map(ConstraintViolation::getMessage)
                .toList();
        String message = errors.isEmpty() ? msg("handle.validation.error") : String.join(". ", errors);
        return buildResponse(HttpStatus.BAD_REQUEST, message, request, ex);
    }

    @ExceptionHandler(MissingServletRequestParameterException.class)
    public ResponseEntity<ApiResponse<UserDto>> handleMissingServletRequestParameter(MissingServletRequestParameterException ex,
                                                                       HttpServletRequest request) {
        return buildResponse(HttpStatus.BAD_REQUEST, msg("handle.handler.method.validation"), request, ex);
    }

    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ApiResponse<UserDto>> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex,
                                                                                     HttpServletRequest request) {
        log.warn("Type mismatch for parameter: '{}' with value: '{}'", ex.getName(), ex.getValue());
        return buildResponse(HttpStatus.BAD_REQUEST, msg("handle.method.argument.type.mismatch"), request, ex);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<UserDto>> handleGeneric(Exception ex, HttpServletRequest request) {
        return buildResponse(HttpStatus.INTERNAL_SERVER_ERROR, msg("handle.generic"),
                request, ex);
    }

    private <T> ResponseEntity<ApiResponse<T>> buildResponse(
            HttpStatus status, String message, HttpServletRequest request, Exception ex) {

        String user = request.getUserPrincipal() != null ? request.getUserPrincipal().getName() : "anonymous";

        AppLogLevel level = (ex instanceof IllegalArgumentException || ex instanceof ConstraintViolationException) ?
                AppLogLevel.WARN : AppLogLevel.ERROR;
        String logger = ex.getStackTrace().length > 0 ? ex.getStackTrace()[0].getClassName() : 
                ex.getClass().getSimpleName();

        AppLogDto dto = new AppLogDto(
                null,
                Instant.now(),
        level,
        logger,
        ex.getClass().getSimpleName(),
        ex.getMessage(),
        user,
        request.getRequestURI()
        );
        
        appLogService.log(dto);

        if (status.is5xxServerError()) {
            StringWriter writer = new StringWriter();
            ex.printStackTrace(new PrintWriter(writer));
            log.error("GlobalExceptionHandler | user={} path={} status={} message={}\n{}",
                    user, request.getRequestURI(), status.value(), message, writer);
        } else {
            log.warn("GlobalExceptionHandler: user: {} path: {} message: {}",
                    user, request.getRequestURI(), message);
        }
        return ApiResponseFactory.error(status, ex.getClass().getSimpleName(), message, request);
    }

    private String msg(String code) {
        return messageSource.getMessage(code, null, LocaleContextHolder.getLocale());
    }
}

package com.example.expensetracker.exception;

import org.springframework.http.HttpStatus;
import org.springframework.security.core.AuthenticationException;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.UNAUTHORIZED)
public class UnauthorizedException extends AuthenticationException {

    public UnauthorizedException(String message) {
        super(message);
    }
}

package com.example.expensetracker.exception;

public class UserNotFoundByIdException extends RuntimeException {
    public UserNotFoundByIdException(String message) {
        super(message);
    }
}

package com.example.expensetracker;

import io.swagger.v3.oas.annotations.OpenAPIDefinition;
import io.swagger.v3.oas.annotations.info.Info;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.scheduling.annotation.EnableScheduling;

@EnableScheduling
@SpringBootApplication
@EnableCaching
@OpenAPIDefinition(info = @Info(title = "Expense Tracker API", version = "1.0"))
public class ExpenseTrackerApplication {

    public static void main(String[] args) {
        SpringApplication.run(ExpenseTrackerApplication.class, args);
    }

}

package com.example.expensetracker.logging.applog;

import org.springframework.data.annotation.Id;
import org.springframework.data.elasticsearch.annotations.DateFormat;
import org.springframework.data.elasticsearch.annotations.Document;
import org.springframework.data.elasticsearch.annotations.Field;
import org.springframework.data.elasticsearch.annotations.FieldType;

import java.time.Instant;

@Document(indexName = "app-logs")
public class AppLog {

    @Id
    private String id;
    @Field(type = FieldType.Date, format = DateFormat.date_time)
    private Instant timestamp;
    private AppLogLevel level;
    private String logger;
    private String errorType;
    private String message;
    private String userEmail;
    private String endPoint;

    public AppLog() {
    }

    public AppLog(String id, 
                  Instant timestamp, 
                  AppLogLevel level, 
                  String logger,
                  String errorType,
                  String message, 
                  String userEmail, 
                  String endPoint) {
        this.id = id;
        this.timestamp = timestamp;
        this.level = level;
        this.logger = logger;
        this.errorType = errorType;
        this.message = message;
        this.userEmail = userEmail;
        this.endPoint = endPoint;
    }

    public String getId() {
        return id;
    }

    public Instant getTimestamp() {
        return timestamp;
    }

    public AppLogLevel getLevel() {
        return level;
    }

    public String getLogger() {
        return logger;
    }

    public String getMessage() {
        return message;
    }

    public String getUserEmail() {
        return userEmail;
    }

    public String getEndPoint() {
        return endPoint;
    }

    public void setId(String id) {
        this.id = id;
    }

    public void setTimestamp(Instant timestamp) {
        this.timestamp = timestamp;
    }

    public void setLevel(AppLogLevel level) {
        this.level = level;
    }

    public void setLogger(String logger) {
        this.logger = logger;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public void setUserEmail(String userEmail) {
        this.userEmail = userEmail;
    }

    public void setEndPoint(String endPoint) {
        this.endPoint = endPoint;
    }

    public String getErrorType() {
        return errorType;
    }

    public void setErrorType(String errorType) {
        this.errorType = errorType;
    }

    public static AppLog from(AppLogDto dto) {
        return new AppLog(
                dto.getId(),
                dto.getTimestamp(),
                dto.getLevel(),
                dto.getLogger(),
                dto.getErrorType(),
                dto.getMessage(),
                dto.getUserEmail(),
                dto.getEndPoint()
        );
    }
}

package com.example.expensetracker.logging.applog;

import java.time.Instant;
import java.util.Objects;

public class AppLogDto {

    private String id;
    private Instant timestamp;
    private AppLogLevel level;
    private String logger;
    private String errorType;
    private String message;
    private String userEmail;
    private String endPoint;
    
    
    public AppLogDto() {}

    public AppLogDto(String id, Instant timestamp, AppLogLevel level, String logger, String errorType, 
                     String message, String userEmail, String endPoint) {
        this.id = id;
        this.timestamp = timestamp;
        this.level = level;
        this.logger = logger;
        this.errorType = errorType;
        this.message = message;
        this.userEmail = userEmail;
        this.endPoint = endPoint;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public Instant getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(Instant timestamp) {
        this.timestamp = timestamp;
    }

    public AppLogLevel getLevel() {
        return level;
    }

    public void setLevel(AppLogLevel level) {
        this.level = level;
    }

    public String getLogger() {
        return logger;
    }

    public void setLogger(String logger) {
        this.logger = logger;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public String getUserEmail() {
        return userEmail;
    }

    public void setUserEmail(String userEmail) {
        this.userEmail = userEmail;
    }

    public String getEndPoint() {
        return endPoint;
    }

    public void setEndPoint(String endPoint) {
        this.endPoint = endPoint;
    }

    public String getErrorType() {
        return errorType;
    }

    public void setErrorType(String errorType) {
        this.errorType = errorType;
    }

    public static AppLogDto from(AppLog entity) {
        return new AppLogDto(
                entity.getId(),
                entity.getTimestamp(),
                entity.getLevel(),
                entity.getLogger(),
                entity.getErrorType(),
                entity.getMessage(),
                entity.getUserEmail(),
                entity.getEndPoint()
        );
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        AppLogDto logDto = (AppLogDto) o;
        return Objects.equals(id, logDto.id) && 
                Objects.equals(timestamp, logDto.timestamp) && 
                level == logDto.level && 
                Objects.equals(logger, logDto.logger) &&
                Objects.equals(errorType, logDto.errorType) &&
                Objects.equals(message, logDto.message) && 
                Objects.equals(userEmail, logDto.userEmail) && 
                Objects.equals(endPoint, logDto.endPoint);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, timestamp, level, logger, errorType, message, userEmail, endPoint);
    }
}

package com.example.expensetracker.logging.applog;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.time.Instant;

@Component
public class AppLogFilter extends OncePerRequestFilter {
    
    private final AppLogService appLogService;

    public AppLogFilter(AppLogService appLogService) {
        this.appLogService = appLogService;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                    HttpServletResponse response, 
                                    FilterChain filterChain) throws ServletException, IOException {
        long start = System.currentTimeMillis();
        try {
            filterChain.doFilter(request, response);
        } finally {
            long duration = System.currentTimeMillis() - start;
            
            Authentication auth = SecurityContextHolder.getContext().getAuthentication();
            String userEmail = (auth != null && auth.isAuthenticated()) ? auth.getName() : "ANONYMOUS";

            AppLogDto logDto = getAppLogDto(request, response, duration, userEmail);

            appLogService.log(logDto);
        }
    }

    private static AppLogDto getAppLogDto(HttpServletRequest request, 
                                          HttpServletResponse response, 
                                          long duration, 
                                          String userEmail) {
        return new AppLogDto(
                null,
                Instant.now(),
                AppLogLevel.INFO,
                "HTTP",
                null,
                String.format("%s %s -> %d (%d ms)",
                        request.getMethod(),
                        request.getRequestURI(),
                        response.getStatus(),
                        duration),
                userEmail,
                request.getRequestURI()
        );
    }
}

package com.example.expensetracker.logging.applog;

public enum AppLogLevel {
    DEBUG,
    INFO,
    WARN,
    ERROR,
}

package com.example.expensetracker.logging.applog;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.elasticsearch.repository.ElasticsearchRepository;

public interface AppLogRepository extends ElasticsearchRepository<AppLog, String> {
    Page<AppLog> findByUserEmail(String userEmail, Pageable pageable);
}

    package com.example.expensetracker.logging.applog;
    
    import org.springframework.data.domain.Page;
    import org.springframework.data.domain.Pageable;
    import org.springframework.stereotype.Service;
    
    @Service
    public class AppLogService {
    
        private final AppLogRepository appLogRepository;
    
        public AppLogService(AppLogRepository appLogRepository) {
            this.appLogRepository = appLogRepository;
        }
    
        public AppLogDto log(AppLogDto dto) {
            AppLog entity = AppLog.from(dto);
            AppLog saved = appLogRepository.save(entity);
            return AppLogDto.from(saved);
        }
    
        public Page<AppLogDto> findAll(Pageable pageable) {
            return appLogRepository.findAll(pageable).map(AppLogDto::from);
        }
    
        public Page<AppLogDto> findByUserEmail(String email, Pageable pageable) {
            return appLogRepository.findByUserEmail(email, pageable).map(AppLogDto::from);
        }
    }

package com.example.expensetracker.logging.audit;

import com.example.expensetracker.model.User;
import jakarta.persistence.*;

import java.time.Instant;

@Entity
@Table(name = "admin_audit")
public class Audit {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    private AuditAction action;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "target_user_id", nullable = false)
    private User targetUser;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "performed_by", nullable = false)
    private User performedBy;

    private Instant timeStamp = Instant.now();

    public Audit() {
    }

    public Audit(AuditAction action, User targetUser, User performedBy) {
        this.action = action;
        this.targetUser = targetUser;
        this.performedBy = performedBy;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public AuditAction getAction() {
        return action;
    }

    public void setAction(AuditAction action) {
        this.action = action;
    }

    public User getTargetUser() {
        return targetUser;
    }

    public void setTargetUser(User targetUser) {
        this.targetUser = targetUser;
    }

    public User getPerformedBy() {
        return performedBy;
    }

    public void setPerformedBy(User performedBy) {
        this.performedBy = performedBy;
    }

    public Instant getTimeStamp() {
        return timeStamp;
    }

    public void setTimeStamp(Instant timeStamp) {
        this.timeStamp = timeStamp;
    }

    @PrePersist
    protected void onCreate() {
        this.timeStamp = Instant.now();
    }
}

package com.example.expensetracker.logging.audit;

public enum AuditAction {
    BAN,
    UNBAN,
    DELETE,
    CREATE,
    PROMOTE,
    DEMOTE,
    CHANGE_PASSWORD
}

package com.example.expensetracker.logging.audit;

import java.time.Instant;
import java.util.Objects;

public final class AuditDto {

    private final Long id;
    private final AuditAction action;
    private final String targetUserEmail;
    private final String performedByEmail;
    private final Instant timeStamp;


    public AuditDto(Long id, AuditAction action, String targetUserEmail, String performedByEmail, Instant timeStamp) {
        this.id = id;
        this.action = action;
        this.targetUserEmail = targetUserEmail;
        this.performedByEmail = performedByEmail;
        this.timeStamp = timeStamp;
    }

    public Long getId() {
        return id;
    }

    public AuditAction getAction() {
        return action;
    }

    public String getTargetUser() {
        return targetUserEmail;
    }

    public String getPerformedBy() {
        return performedByEmail;
    }

    public Instant getTimeStamp() {
        return timeStamp;
    }

    public static AuditDto from(Audit entity) {
        AuditDto dto = new AuditDto(
                entity.getId(),
                entity.getAction(),
                entity.getTargetUser().getEmail(),
                entity.getPerformedBy().getEmail(),
                entity.getTimeStamp());
        return dto;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        AuditDto auditDto = (AuditDto) o;
        return action == auditDto.action &&
                Objects.equals(targetUserEmail, auditDto.targetUserEmail) &&
                Objects.equals(performedByEmail, auditDto.performedByEmail) &&
                Objects.equals(timeStamp, auditDto.timeStamp);
    }

    @Override
    public int hashCode() {
        return Objects.hash(action, targetUserEmail, performedByEmail, timeStamp);
    }
}

package com.example.expensetracker.logging.audit;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AuditRepository extends JpaRepository<Audit, Long> {
    Page<Audit> findByPerformedBy_Id(Long adminId, Pageable pageable);
}

package com.example.expensetracker.logging.audit;

import com.example.expensetracker.model.User;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.time.Instant;

import static com.example.expensetracker.logging.audit.AuditAction.CHANGE_PASSWORD;

@Service
public class AuditService {
    
    private final AuditRepository auditRepository;

    public AuditService(AuditRepository auditRepository) {
        this.auditRepository = auditRepository;
    }
    
    public AuditDto logAction(AuditAction action, User target, User performedBy) {
        Audit audit = new Audit(action, target, performedBy);
        return AuditDto.from(auditRepository.save(audit));
    }

    public Page<AuditDto> getAll(Pageable pageable) {
        return auditRepository.findAll(pageable).map(AuditDto::from);
    }

    public Page<AuditDto> getByAdmin(Long adminId, Pageable pageable) {
        return auditRepository.findByPerformedBy_Id(adminId, pageable).map(AuditDto::from);
    }

    public void logPasswordChange(User user) {
        Audit audit = new Audit(CHANGE_PASSWORD, user, user);
        audit.setTimeStamp(Instant.now());
        auditRepository.save(audit);
    }
}

package com.example.expensetracker.mapper;

import com.example.expensetracker.dto.RecurringTransactionDto;
import com.example.expensetracker.dto.RecurringTransactionRequestDto;
import com.example.expensetracker.model.Category;
import com.example.expensetracker.model.RecurringTransaction;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface RecurringTransactionMapper {
    
    @Mapping(target = "categoryId", source = "category.id")
    @Mapping(target = "categoryName", source = "category.name")
    RecurringTransactionDto toDto(RecurringTransaction entity);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "category", source = "category")
    @Mapping(target = "user", ignore = true)
    @Mapping(target = "nextExecutionDate", expression = "java(java.time.LocalDate.now())")
    @Mapping(target = "active", constant = "true")
    RecurringTransaction toEntity(RecurringTransactionDto dto, Category category);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "category", source = "category")
    @Mapping(target = "user", ignore = true)
    @Mapping(target = "nextExecutionDate", expression = "java(java.time.LocalDate.now())")
    @Mapping(target = "active", constant = "true")
    RecurringTransaction fromRequest(RecurringTransactionRequestDto dto, Category category);
}

package com.example.expensetracker.model;

import jakarta.persistence.*;

import java.util.Objects;

@Entity
@Table(name = "categories")
public class Category {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true, length = 50)
    private String name;
    
    public Category() {}

    public Category(String name) {
        this.name = name;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Category category = (Category) o;
        return Objects.equals(id, category.id);
    }

    @Override
    public int hashCode() {
        return this.id != null ? id.hashCode() : getClass().hashCode();
    }

    @Override
    public String toString() {
        return "Category{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
}

package com.example.expensetracker.model;

import jakarta.persistence.*;

import java.math.BigDecimal;
import java.time.Instant;

@Entity
@Table(name = "expenses")
public class Expense {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    @Column(nullable = false, precision = 19, scale = 2)
    private BigDecimal amount;
    
    @Column(name = "occurred_at", nullable = false)
    private Instant occurredAt;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id")
    private Category category; 
    
    private String description;

    public Expense() {}

    public Expense(Long id, User user, BigDecimal amount, Instant occurredAt, Category category, String description) {
        this.id = id;
        this.user = user;
        this.amount = amount;
        this.occurredAt = occurredAt;
        this.category = category;
        this.description = description;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public BigDecimal getAmount() {
        return amount;
    }

    public void setAmount(BigDecimal amount) {
        this.amount = amount;
    }

    public Instant getOccurredAt() {
        return occurredAt;
    }

    public void setOccurredAt(Instant occurredAt) {
        this.occurredAt = occurredAt;
    }

    public Category getCategory() {
        return category;
    }

    public void setCategory(Category category) {
        this.category = category;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }
}

package com.example.expensetracker.model;

public enum Month {
    JANUARY,
    FEBRUARY,
    MARCH,
    APRIL,
    MAY,
    JUNE,
    JULY,
    AUGUST,
    SEPTEMBER,
    OCTOBER,
    NOVEMBER,
    DECEMBER
}

package com.example.expensetracker.model;

import jakarta.persistence.*;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.Objects;

@Entity
@Table(name = "recurring_transactions")
public class RecurringTransaction {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private BigDecimal amount;

    @Column(nullable = false)
    private String description;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", nullable = false)
    private Category category;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(nullable = false)
    private int intervalDays;

    @Column(nullable = false)
    private LocalDate nextExecutionDate;
    
    @Column(nullable = false)
    private boolean active = true;

    public RecurringTransaction() {}

    public RecurringTransaction(BigDecimal amount, String description, Category category, User user, int intervalDays,
                                LocalDate nextExecutionDate) {
        this.amount = amount;
        this.description = description;
        this.category = category;
        this.user = user;
        this.intervalDays = intervalDays;
        this.nextExecutionDate = nextExecutionDate;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public BigDecimal getAmount() {
        return amount;
    }

    public void setAmount(BigDecimal amount) {
        this.amount = amount;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public Category getCategory() {
        return category;
    }

    public void setCategory(Category category) {
        this.category = category;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public int getIntervalDays() {
        return intervalDays;
    }

    public void setIntervalDays(int intervalDays) {
        this.intervalDays = intervalDays;
    }

    public LocalDate getNextExecutionDate() {
        return nextExecutionDate;
    }

    public void setNextExecutionDate(LocalDate nextExecutionDate) {
        this.nextExecutionDate = nextExecutionDate;
    }

    public boolean isActive() {
        return active;
    }

    public void setActive(boolean active) {
        this.active = active;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        RecurringTransaction that = (RecurringTransaction) o;
        return id != null && id.equals(that.id);
    }

    @Override
    public int hashCode() {
        return this.id != null ? id.hashCode() : getClass().hashCode();
    }
}

package com.example.expensetracker.model;

public enum Role {
    USER,
    ADMIN,
    MODERATOR
}

package com.example.expensetracker.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import org.hibernate.annotations.Where;

import java.math.BigDecimal;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "users")
@Where(clause = "deleted = false")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Email(message = "{user.email.invalid}")
    @NotBlank(message = "{user.email.not-blank}")
    @Column(unique = true, nullable = false)
    private String email;

    @NotBlank(message = "{user.password.not-blank}")
    private String password;

    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "user_roles", joinColumns = @JoinColumn(name = "user_id"))
    @Column(name = "role")
    @Enumerated(EnumType.STRING)
    private Set<Role> roles = new HashSet<>();

    @Column(name = "banned", nullable = false)
    private boolean banned = false;
    
    @Column(name = "deleted", nullable = false)
    private boolean deleted = false;

    @Column(name = "total_expenses", nullable = false, precision = 19, scale = 2)
    private BigDecimal totalExpenses = BigDecimal.ZERO;

    public User() {}

    public User(Long id, String email, String password, Set<Role> roles,  boolean banned) {
        this.id = id;
        this.email = email;
        this.password = password;
        this.roles = roles;
        this.banned = banned;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Set<Role> getRoles() {
        return roles;
    }

    public void setRoles(Set<Role> roles) {
        this.roles = roles;
    }

    public boolean isBanned() {
        return banned;
    }

    public void setBanned(boolean banned) {
        this.banned = banned;
    }

    public boolean isDeleted() {
        return deleted;
    }

    public void setDeleted(boolean deleted) {
        this.deleted = deleted;
    }

    public BigDecimal getTotalExpenses() {
        return totalExpenses;
    }

    public void setTotalExpenses(BigDecimal totalExpenses) {
        this.totalExpenses = totalExpenses;
    }

    public void increaseTotalExpenses(BigDecimal amount) {
        this.totalExpenses = this.totalExpenses.add(amount);
    }

    public void decreaseTotalExpenses(BigDecimal amount) {
        this.totalExpenses = this.totalExpenses.subtract(amount);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User that = (User) o;
        return id != null && id.equals(that.id);
    }

    @Override
    public int hashCode() {
        return this.id != null ? id.hashCode() : getClass().hashCode();
    }

    public static class UserBuilder {
        private Long id;
        private String email;
        private String password;
        private Set<Role> roles = new HashSet<>();
        private boolean banned = false;

        public UserBuilder id(Long id) {
            this.id = id;
            return this;
        }

        public UserBuilder email(String email) {
            this.email = email;
            return this;
        }

        public UserBuilder password(String password) {
            this.password = password;
            return this;
        }

        public UserBuilder roles(Set<Role> roles) {
            this.roles = roles;
            return this;
        }

        public UserBuilder banned(boolean banned) {
            this.banned = banned;
            return this;
        }

        public User build() {
            return new User(id, email, password, roles,  banned);
        }
    }

    public static UserBuilder builder() {
        return new UserBuilder();
    }
}

package com.example.expensetracker.repository;

import com.example.expensetracker.model.Category;
import org.springframework.data.jpa.repository.JpaRepository;

public interface CategoryRepository extends JpaRepository<Category, Long> {
}

package com.example.expensetracker.repository;

import com.example.expensetracker.dto.CategorySumDto;
import com.example.expensetracker.model.Expense;
import com.example.expensetracker.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

public interface ExpenseRepository extends JpaRepository<Expense, Long> {
    @Query("""
            SELECT new com.example.expensetracker.dto.CategorySumDto(
            COALESCE(c.name, 'UNCATEGORIZED'), SUM(e.amount))
            FROM Expense e LEFT JOIN e.category c
            WHERE e.user.id = :userId AND e.occurredAt
            BETWEEN :from AND :to GROUP BY c.name""")
    List<CategorySumDto> sumByCategoryForUserBetween(Long userId, Instant from, Instant to);

    @Query("SELECT COALESCE(SUM(e.amount), 0) FROM Expense e WHERE e.user.id = :userId AND e.occurredAt " +
            "BETWEEN :from AND :to")
    BigDecimal totalForUserBetween(Long userId, Instant from, Instant to);

    @Query("""
            SELECT new com.example.expensetracker.dto.CategorySumDto(c.name, SUM(e.amount))
            FROM Expense e
            JOIN e.category c
            WHERE e.user = :user
            AND e.occurredAt BETWEEN :start AND :end GROUP BY c.name
            """)
    List<CategorySumDto> getMonthlyReport(@Param("user") User user,
                                          @Param("start") Instant start,
                                          @Param("end") Instant end);
}

package com.example.expensetracker.repository;

import com.example.expensetracker.model.RecurringTransaction;
import org.springframework.data.jpa.repository.JpaRepository;

import java.time.LocalDate;
import java.util.List;

public interface RecurringTransactionRepository extends JpaRepository<RecurringTransaction, Long> {
    List<RecurringTransaction> findAllByNextExecutionDateLessThanEqual(LocalDate date);
    List<RecurringTransaction> findAllByUser_Email(String email);
}

package com.example.expensetracker.repository;

import com.example.expensetracker.model.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    boolean existsByEmail(String email);
}

package com.example.expensetracker.security;

import com.example.expensetracker.dto.ApiResponse;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.stereotype.Component;

import java.io.IOException;

import static com.example.expensetracker.dto.ApiResponseFactory.forbidden;

@Component
public class CustomAccessDeniedHandler implements AccessDeniedHandler {

    private final ObjectMapper objectMapper;

    public CustomAccessDeniedHandler(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response,
                       AccessDeniedException accessDeniedException) throws IOException {
        ApiResponse<?> apiResponse = forbidden(request);

        response.setContentType("application/json");
        response.setStatus(HttpServletResponse.SC_FORBIDDEN);
        objectMapper.writeValue(response.getOutputStream(), apiResponse);
    }
}

package com.example.expensetracker.security;

import com.example.expensetracker.dto.ApiResponse;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.time.Instant;

import static com.example.expensetracker.dto.ApiResponseFactory.unauthorized;

@Component
public class CustomAuthEntryPoint implements AuthenticationEntryPoint {

    private final ObjectMapper objectMapper;

    public CustomAuthEntryPoint(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException {
        ApiResponse<?> apiResponse = unauthorized(request);

        response.setContentType("application/json");
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        objectMapper.writeValue(response.getOutputStream(), apiResponse);
    }
}

package com.example.expensetracker.security;

import com.example.expensetracker.details.UserDetailsImpl;
import com.example.expensetracker.model.User;
import com.example.expensetracker.repository.UserRepository;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service("customUserDetailsService")
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository users;

    public CustomUserDetailsService(UserRepository users) {
        this.users = users;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User u = users.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω " + email));
        return new UserDetailsImpl(u);
    }
}

package com.example.expensetracker.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
public class JwtAuthFilter extends OncePerRequestFilter {

    private static final Logger log = LoggerFactory.getLogger(JwtAuthFilter.class);

    private final JwtUtil jwtUtil;
    private final CustomUserDetailsService userDetailsService;

    public JwtAuthFilter(JwtUtil jwtUtil, CustomUserDetailsService userDetailsService) {
        this.jwtUtil = jwtUtil;
        this.userDetailsService = userDetailsService;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        log.info("–ú—ã –≤–Ω—É—Ç—Ä–∏ —Ñ–∏–ª—å—Ç—Ä–∞! URI: {}", request.getRequestURI());
        String token = resolveToken(request);
        log.info("–ó–∞–≥–æ–ª–æ–≤–æ–∫ –≤—Ö–æ–¥—è—â–µ–π –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏: {}", request.getHeader("Authorization"));

        String uri = request.getRequestURI();
        if (uri.startsWith("/api/auth") ||
                uri.startsWith("/swagger-ui") ||
                uri.startsWith("/v3/api-docs") ||
                uri.startsWith("/webjars")) {
            filterChain.doFilter(request, response);
            return;
        }

        if (token == null && SecurityContextHolder.getContext().getAuthentication() == null) {
            log.warn("–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç —Ç–æ–∫–µ–Ω - –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω");
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Missing or invalid token");
            return;
        }

        if (token != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            try {
                String email = jwtUtil.getSubject(token);
                UserDetails userDetails = userDetailsService.loadUserByUsername(email);

                UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(userDetails,
                        null, userDetails.getAuthorities());

                auth.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(auth);
            } catch (Exception e) {
                log.warn("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–∑–±–æ—Ä–µ —Ç–æ–∫–µ–Ω–∞: {}", e.getMessage());
                SecurityContextHolder.clearContext();
            }
        }
        filterChain.doFilter(request, response);
    }

    private String resolveToken(HttpServletRequest request) {
        String bearer = request.getHeader("Authorization");
        if (bearer != null && bearer.startsWith("Bearer ")) {
            return bearer.substring(7);
        }
        return null;
    }
}

package com.example.expensetracker.security;

import com.example.expensetracker.model.Role;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.UUID;

@Component
public class JwtUtil {

    private static Logger log = LoggerFactory.getLogger(JwtUtil.class);

    @Value("${app.jwt.secret}")
    private String secret;

    @Value("${app.jwt.access-expiration}")
    private long accessExpiration;

    @Value("${app.jwt.refresh-expiration}")
    private long refreshExpiration;

    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
    }

    private String buildToken(String email, Role role, long expiration) {
        return Jwts.builder()
                .subject(email)
                .claim("role", role != null ? role.name() : null)
                .claim("jti", UUID.randomUUID().toString())
                .issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(getSigningKey())
                .compact();
    }

    public String generateAccessToken(String email, Role role) {
        log.info("–°–æ–∑–¥–∞–Ω access-—Ç–æ–∫–µ–Ω –¥–ª—è {}", email);
        return buildToken(email, role, accessExpiration);
    }

    public String generateRefreshToken(String email) {
        log.info("–°–æ–∑–¥–∞–Ω refresh-—Ç–æ–∫–µ–Ω –¥–ª—è {}", email);
        return buildToken(email, null, refreshExpiration);
    }

    public Jws<Claims> parse(String token) {
        log.info("–ê–Ω–∞–ª–∏–∑ —Ç–æ–∫–µ–Ω–∞");
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token);
    }

    public String getSubject(String token) {
        return parse(token).getPayload().getSubject();
    }
}


spring:
  cache:
    type: caffeine
    caffeine:
      spec: maximumSize=1000, expireAfterWrite=1h
  scheduler:
    recurring-cron: 0 0 1 * * *
  datasource:
    url: jdbc:postgresql://postgres:5432/expense_tracker
    username: postgres
    password: postgres
    driver-class-name: org.postgresql.Driver
  jpa:
    hibernate:
      ddl-auto: none
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
  liquibase:
    change-log: classpath:db/changelog-master.xml
    contexts: dev
    clear-checksums: false
    drop-first: false
  elasticsearch:
    uris: http://elasticsearch:9200

server:
  port: 8080

spring:
  datasource:
    url: jdbc:postgresql://${DB_HOST:prod-db}:${DB_PORT:5432}/expense_tracker
    username: ${DB_USER}
    password: ${DB_PASS}
    driver-class-name: org.postgresql.Driver
  jpa:
    hibernate:
      ddl-auto: validate
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
  liquibase:
    change-log: classpath:db/changelog-master.yaml
  elasticsearch:
    uris: ${ELASTIC_URI:http://prod-elastic:9200}

spring:
  cache:
    type: caffeine
    caffeine:
      spec: maximumSize=1000, expireAfterWrite=1h
  scheduler:
    recurring-cron: 0 0 3 * * *
    zone: Europe/Moscow
  application:
    name: expense-tracker
  messages:
    basename: ValidationMessages
    encoding: UTF-8
  web:
    locale: ru
    locale-resolver: accept_header

logging:
  level:
    org.springframework.web: DEBUG
    org.hibernate.SQL: DEBUG
    org.springframework.security: DEBUG
    com.example.expensetracker: DEBUG

app:
  jwt:
    secret: "Nohackerwilleverguessthiskeynotevenyou12345"
    access-expiration: 900000
    refresh-expiration: 604800000
  admin:
    email: admin@example.com
    password: admin

<?xml version="1.0" encoding="UTF-8" ?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="
        http://www.liquibase.org/xml/ns/dbchangelog
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">

    <changeSet id="000-create-users" author="lamer">
        <createTable tableName="users" ifNotExists="true">
            <column name="id" type="bigserial">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="email" type="varchar(255)">
                <constraints nullable="false" unique="true"/>
            </column>
            <column name="password" type="varchar(255)" />
            <column name="banned" type="boolean" defaultValueBoolean="false"/>
        </createTable>

        <createTable tableName="user_roles">
            <column name="user_id" type="bigint">
                <constraints nullable="false"/>
            </column>
            <column name="role" type="varchar(50)">
                <constraints nullable="false"/>
            </column>
        </createTable>

        <addPrimaryKey tableName="user_roles"
                       columnNames="user_id, role"
                       constraintName="pk_user_roles"/>

        <addForeignKeyConstraint baseTableName="user_roles"
                                 baseColumnNames="user_id"
                                 referencedTableName="users"
                                 referencedColumnNames="id"
                                 constraintName="fk_user_roles_users"/>
    </changeSet>
</databaseChangeLog>

<?xml version="1.0" encoding="UTF-8" ?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="
        http://www.liquibase.org/xml/ns/dbchangelog
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">

    <changeSet id="002-add-audit-table" author="lamer">
        <createTable tableName="admin_audit">
            <column name="id" type="bigserial">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="action" type="varchar(50)">
                    <constraints nullable="false"/>
            </column>
            <column name="target_user_id" type="bigint">
                    <constraints nullable="false"/>
            </column>
            <column name="performed_by" type="bigint">
            <constraints nullable="false"/>
        </column>
            <column name="time_stamp" type="timestamp">
            <constraints nullable="false"/>
        </column>
        </createTable>
        
        <addForeignKeyConstraint baseTableName="admin_audit" 
                                 baseColumnNames="target_user_id"
                                 referencedTableName="users"
                                 referencedColumnNames="id"
                                 constraintName="fk_admin_audit_target_user"/>
        
        <addForeignKeyConstraint baseTableName="admin_audit" 
                                 baseColumnNames="performed_by" 
                                 constraintName="fk_admin_audit_performed_by" 
                                 referencedTableName="users"
                                 referencedColumnNames="id"/>
    </changeSet>
</databaseChangeLog>

<?xml version="1.0" encoding="UTF-8" ?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="
        http://www.liquibase.org/xml/ns/dbchangelog
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">

    <changeSet id="005-create-categories-table" author="lamer">
        <createTable tableName="categories">
            <column name="id" type="bigserial">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="name" type="varchar(100)">
                <constraints nullable="false" unique="true"/>
            </column>
            <column name="description" type="text"/>
        </createTable>
    </changeSet>
</databaseChangeLog>

<?xml version="1.0" encoding="UTF-8" ?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="
        http://www.liquibase.org/xml/ns/dbchangelog
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">

    <changeSet id="003-expenses-table" author="lamer">
    <createTable tableName="expenses">
        <column name="id" type="bigserial">
            <constraints primaryKey="true" nullable="false"/>
        </column>
        <column name="user_id" type="bigint">
            <constraints nullable="false"/>
        </column>
        <column name="amount" type="numeric(19,2)">
            <constraints nullable="false"/>
        </column>
        <column name="occurred_at" type="timestamp">
            <constraints nullable="false"/>
        </column>
        <column name="category_id" type="bigint"/>
        <column name="description" type="text"/>
    </createTable>

    <addForeignKeyConstraint baseTableName="expenses"
                             baseColumnNames="user_id"
                             referencedTableName="users"
                             referencedColumnNames="id"
                             constraintName="fk_expense_user"/>

        <addForeignKeyConstraint baseTableName="expenses"
                                 baseColumnNames="category_id"
                                 referencedTableName="categories"
                                 referencedColumnNames="id"
                                 constraintName="fk_expense_category"/>
</changeSet>
        </databaseChangeLog>

<?xml version="1.0" encoding="UTF-8" ?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="
        http://www.liquibase.org/xml/ns/dbchangelog
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">

    <changeSet id="004-add-deleted-total-expenses" author="lamer">
        <addColumn tableName="users">
            <column name="deleted" type="boolean" defaultValueBoolean="false">
                <constraints nullable="false"/>
            </column>
            <column name="total_expenses" type="numeric(19,2)" defaultValueNumeric="0">
                <constraints nullable="false"/>
            </column>
        </addColumn>
    </changeSet>
    </databaseChangeLog>

<?xml version="1.0" encoding="UTF-8" ?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="
        http://www.liquibase.org/xml/ns/dbchangelog
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">

    <changeSet id="006-create-recurring_transactions-table" author="lamer">
        <createTable tableName="recurring_transactions">
            <column name="id" type="bigserial">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="amount" type="numeric(19,2)">
                <constraints nullable="false"/>
            </column>
            <column name="description" type="text">
            <constraints nullable="false"/>
            </column>
            <column name="category_id" type="bigint">
                <constraints nullable="false"/>
            </column>
            <column name="user_id" type="bigint">
                <constraints nullable="false"/>
            </column>
            <column name="interval_days" type="int">
                <constraints nullable="false"/>
            </column>
            <column name="next_execution_date" type="date">
                <constraints nullable="false"/>
            </column>
            <column name="active" type="boolean" defaultValueBoolean="true">
                <constraints nullable="false"/>
            </column>
        </createTable>

        <addForeignKeyConstraint baseTableName="recurring_transactions"
                                 baseColumnNames="user_id"
                                 referencedTableName="users"
                                 referencedColumnNames="id"
                                 constraintName="fk_recurring_transactions_user"/>

        <addForeignKeyConstraint baseTableName="recurring_transactions"
                                 baseColumnNames="category_id"
                                 referencedTableName="categories"
                                 referencedColumnNames="id"
                                 constraintName="fk_recurring_transactions_category"/>
    </changeSet>
</databaseChangeLog>

<?xml version="1.0" encoding="UTF-8" ?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="
        http://www.liquibase.org/xml/ns/dbchangelog
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">

    <include file="db/changelog/001-create-users.xml"/>
    <include file="db/changelog/002-add-audit-table.xml"/>
    <include file="db/changelog/003-create-categories-table.xml"/>
    <include file="/db/changelog/004-create-expenses-table.xml.xml"/>
    <include file="db/changelog/005-add-deleted-total-expenses.xml"/>
    <include file="/db/changelog/006-create-recurring-transactions-table.xml"/>
</databaseChangeLog>

<configuration>
    <property name="LOG_PATH" value="logs" />
    <property name="LOG_FILE" value="${LOG_PATH}/app.log" />

    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_FILE}</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/app.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>7</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} | %-5level | %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%cyan(%d{HH:mm:ss.SSS}) | %highlight(%-5level) | %magenta(%logger{15}) - %msg%n</pattern>
        </encoder>
    </appender>

    <root level="DEBUG">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="FILE" />
    </root>
</configuration>

# === RegisterDto / LoginDto / User ===
user.name.not-blank=Username cannot be blank
user.email.not-blank=Email is required
user.email.invalid=Invalid email format
user.password.not-blank=Password is required

# === GlobalExceptionHandler ===
handle.bad.credentials=Invalid credentials
handle.access.denied=Access denied
handle.entity.not.found=Requested resource not found
handle.data.integrity.violation=Database constraint violation
handle.illegal.argument=Invalid request
handle.entity.exists=Entity already exists
handle.username.not.found=User not found
handle.user.not.found.by.id=User not found
handle.generic=Internal server error
handle.validation.error=Validation error
handle.handler.method.validation=Request parameter validation error
handle.method.argument.type.mismatch=Invalid user ID format

# === AuthController ===
auth.controller.refresh=Token refreshed successfully
auth.controller.register=Registration successful
auth.controller.login=Login successful

# === AdminController / ModeratorController ===
get.all.users=List of users
get.user.by.id=User found
ban.user=User banned
promote.user=User promoted
demote.user=User demoted
unban.user=User unbanned
delete.user=User deleted
create.admin=Administrator created
create.moder=Moderator created

# === UserController ===
user.controller.get.current.user=Current user
user.controller.password.changed.success=Password changed successfully
user.controller.user.password.old.not-blank=Enter old password
user.controller.user.password.new.not-blank=Enter new password

# === AppLogController ===
app.log.controller.logs.get.all=All logs
app.log.controller.logs.get.by.user=User logs

# === AuditController ===
audit.controller.get.all=Full audit log
audit.controller.get.by.admin=Admin audit log

# === ExpenseController ===
expense.controller.report.ok=Expense report
expense.controller.total.ok=Total spent
expense.controller.report.monthly=Monthly report

# === RecurringTransactionController ===
recurring.transaction.controller.get.all=All recurring transactions
recurring.transaction.controller.create=Recurring transaction created
recurring.transaction.controller.toggle.active=Recurring transaction status changed

# === DateRangeDto ===
date.range.dto.from.is.valid.range=from must be earlier than to
date.range.dto.from.not.null=from cannot be null
date.range.dto.to.not.null=to cannot be null

# === ChangePasswordRequest ===
change.password.request.old.not-blank=Enter old password
change.password.request.new.not-blank=Enter new password

# === RecurringTransactionRequestDto ===
recurring.transaction.request.amount.not.null=Amount is required
recurring.transaction.request.amount.positive=Amount must be positive
recurring.transaction.request.description.not.blank=Description cannot be blank
recurring.transaction.request.category.id.not.null=Category ID is required

# === ModeratorController OpenAPI ===
moder.tag.name=Moderators
moder.tag.desc=User management
moder.get.all.users.sum=Get all users
moder.get.all.users.desc=Returns a paginated list of all users
moder.get.by.id.sum=Get user by ID
moder.get.by.id.desc=Returns detailed user information by ID
moder.get.ban.user.sum=Ban user
moder.get.ban.user.desc=Bans a user, preventing login
moder.get.unban.user.sum=Unban user
moder.get.unban.user.desc=Removes ban and restores access

# === AdminController OpenAPI ===
admin.tag.name=Administrators
admin.tag.desc=User management
admin.get.all.users.sum=Get all users
admin.get.all.users.desc=Returns a paginated list of all users
admin.get.by.id.sum=Get user by ID
admin.get.by.id.desc=Returns detailed user information by ID
admin.ban.user.sum=Ban user
admin.ban.user.desc=Bans a user, preventing login
admin.unban.user.sum=Unban user
admin.unban.user.desc=Removes ban and restores access
admin.promote.user.sum=Promote user
admin.promote.user.desc=Grants moderator role to the user
admin.demote.user.sum=Demote user
admin.demote.user.desc=Revokes moderator role from the user
admin.delete.user.sum=Delete user
admin.delete.user.desc=Marks user as deleted and deactivates account
admin.create.admin.sum=Create administrator
admin.create.admin.desc=Creates a new user with administrator role
admin.create.moder.sum=Create moderator
admin.create.moder.desc=Creates a new user with moderator role

# === AppLogController OpenAPI ===
app.log.tag.name=Logs
app.log.tag.desc=Retrieve log lists
app.log.get.all.logs.sum=Get all logs
app.log.get.all.logs.desc=Returns a paginated list of all system logs
app.log.get.by.user.sum=Get logs by user
app.log.get.by.user.desc=Returns all logs for a user by email

# === AuditController OpenAPI ===
audit.tag.name=Audit Trail
audit.tag.desc=View administrative action logs
audit.get.all.audit.sum=Get all audit records
audit.get.all.audit.desc=Returns a paginated list of all audit entries
audit.get.by.admin.sum=Get audit by administrator
audit.get.by.admin.desc=Returns action log for the selected administrator

# === AuthController OpenAPI ===
auth.tag.name=Authentication
auth.tag.desc=User registration, login and token refresh
auth.refresh.sum=Refresh access token
auth.refresh.desc=Refreshes access and refresh token pair using a valid refresh token
auth.register.sum=Register new user
auth.register.desc=Creates a new user and returns user data upon successful registration
auth.login.sum=User login
auth.login.desc=Authenticates user and returns access and refresh tokens

# === ExpenseController OpenAPI ===
expense.tag.name=Expenses
expense.tag.desc=Expense statistics and reports
expense.report.sum=Get expense report
expense.report.desc=Returns expense report for the specified date range
expense.report.monthly.sum=Get monthly report
expense.report.monthly.desc=Returns expense report for the selected month and year
expense.get.total.sum=Get total expenses
expense.get.total.desc=Returns the total amount spent by the user

# === RecurringTransactionController OpenAPI ===
recurring.transaction.tag.name=Recurring Transactions
recurring.transaction.tag.desc=Manage user's recurring transactions
recurring.transaction.get.all.sum=Get all recurring transactions
recurring.transaction.get.all.desc=Returns list of all recurring transactions for the current user
recurring.transaction.create.sum=Create recurring transaction
recurring.transaction.create.desc=Creates a new recurring transaction for a category
recurring.transaction.toggle.active.sum=Toggle active status
recurring.transaction.toggle.active.desc=Activates or deactivates a recurring transaction by ID

# === UserController OpenAPI ===
user.tag.name=Users
user.tag.desc=Manage personal data and account security
user.get.current.user.sum=Get current user
user.get.current.user.desc=Returns data of the authenticated user (ID and email)
user.change.password.sum=Change password
user.change.password.desc=Changes password when current password is provided correctly

# === RegisterDto / LoginDto / User ===
user.name.not-blank=–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º
user.email.not-blank=–ü–æ—á—Ç–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞
user.email.invalid=–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –ø–æ—á—Ç–∞
user.password.not-blank=–ü–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω

# === GlobalExceptionHandler ===
handle.bad.credentials=–ù–µ–≤–µ—Ä–Ω—ã–µ —É—á—ë—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
handle.access.denied=–û—Ç–∫–∞–∑–∞–Ω–æ –≤ –¥–æ—Å—Ç—É–ø–µ
handle.entity.not.found=–ó–∞–ø—Ä–æ—à–µ–Ω–Ω—ã–π —Ä–µ—Å—É—Ä—Å –Ω–µ –Ω–∞–π–¥–µ–Ω
handle.data.integrity.violation=–ù–∞—Ä—É—à–µ–Ω–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
handle.illegal.argument=–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∑–∞–ø—Ä–æ—Å
handle.entity.exists=–°—É—â–Ω–æ—Å—Ç—å —É–∂–µ –µ—Å—Ç—å
handle.username.not.found=–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω
handle.user.not.found.by.id=–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω
handle.generic=–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞
handle.validation.error=–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏
handle.handler.method.validation=–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∑–∞–ø—Ä–æ—Å–∞
handle.method.argument.type.mismatch=–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è

# === AuthController
auth.controller.refresh=–¢–æ–∫–µ–Ω —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω
auth.controller.register=–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ
auth.controller.login=–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ


# === AdminController / ModeratorController ===
get.all.users=–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
get.user.by.id=–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–π–¥–µ–Ω
ban.user=–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω
promote.user=–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–≤—ã—à–µ–Ω
demote.user=–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–Ω–∏–∂–µ–Ω
unban.user=–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω
delete.user=–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–¥–∞–ª—ë–Ω
create.admin=–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä —Å–æ–∑–¥–∞–Ω
create.moder=–ú–æ–¥–µ—Ä–∞—Ç–æ—Ä —Å–æ–∑–¥–∞–Ω

# === UserController ===
user.controller.get.current.user=–¢–µ–∫—É—â–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
user.controller.password.changed.success=–ü–∞—Ä–æ–ª—å —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω—ë–Ω
user.controller.user.password.old.not-blank=–í–≤–µ–¥–∏—Ç–µ —Å—Ç–∞—Ä—ã–π –ø–∞—Ä–æ–ª—å
user.controller.user.password.new.not-blank=–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –ø–∞—Ä–æ–ª—å

# === AppLogController ===
app.log.controller.logs.get.all=–°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ª–æ–≥–æ–≤
app.log.controller.logs.get.by.user=–õ–æ–≥–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è

# === AuditController ===
audit.controller.get.all=–í–µ—Å—å –∞—É–¥–∏—Ç
audit.controller.get.by.admin=–ê—É–¥–∏—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
  
  # === ExpenseController ===
expense.controller.report.ok=–û—Ç—á—ë—Ç —Ä–∞—Å—Ö–æ–¥–æ–≤
expense.controller.total.ok=–í—Å–µ–≥–æ –ø–æ—Ç—Ä–∞—á–µ–Ω–æ
expense.controller.report.monthly=–û—Ç—á—ë—Ç –∑–∞ –º–µ—Å—è—Ü

# === RecurringTransactionController ===
recurring.transaction.controller.get.all=–í—Å–µ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
recurring.transaction.controller.create=–°–æ–∑–¥–∞–Ω–∞ –ø–æ–≤—Ç–æ—Ä—è—é—â–∞—è—Å—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è
recurring.transaction.controller.toggle.active=–°—Ç–∞—Ç—É—Å –ø–æ–≤—Ç–æ—Ä—è—é—â–µ–π—Å—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –∏–∑–º–µ–Ω—ë–Ω

# === DateRangeDto ===
date.range.dto.from.is.valid.range=from –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ä–∞–Ω—å—à–µ to
date.range.dto.from.not.null=from –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å null
date.range.dto.to.not.null=to –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å null
  
  # === ChangePasswordRequest ===
change.password.request.old.not-blank=–í–≤–µ–¥–∏—Ç–µ —Å—Ç–∞—Ä—ã–π –ø–∞—Ä–æ–ª—å
change.password.request.new.not-blank=–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –ø–∞—Ä–æ–ª—å

  # === RecurringTransactionRequestDto ===
recurring.transaction.request.amount.not.null=–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ
recurring.transaction.request.amount.positive=–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–Ω—å—à–µ –Ω—É–ª—è
recurring.transaction.request.description.not.blank=–û–ø–∏—Å–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º
recurring.transaction.request.category.id.not.null=–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ

   # === ModeratorController OpenAPI ===
moder.tag.name=–ú–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã
moder.tag.desc=–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏
moder.get.all.users.sum=–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
moder.get.all.users.desc=–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π
moder.get.by.id.sum=–ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
moder.get.by.id.desc=–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–¥—Ä–æ–±–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ –ø–æ –µ–≥–æ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
moder.get.ban.user.sum=–ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
moder.get.ban.user.desc=–ë–ª–æ–∫–∏—Ä—É–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –¥–µ–ª–∞—è –Ω–µ–≤–æ–∑–º–æ–∂–Ω—ã–º –≤—Ö–æ–¥ –≤ —Å–∏—Å—Ç–µ–º—É
moder.get.unban.user.sum=–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
moder.get.unban.user.desc=–°–Ω–∏–º–∞–µ—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∫—É –∏ –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –¥–æ—Å—Ç—É–ø –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é

# === AdminController OpenAPI ===
admin.tag.name=–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã
admin.tag.desc=–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏
admin.get.all.users.sum=–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
admin.get.all.users.desc=–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π
admin.get.by.id.sum=–ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
admin.get.by.id.desc=–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–¥—Ä–æ–±–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ –ø–æ –µ–≥–æ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É
admin.ban.user.sum=–ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
admin.ban.user.desc=–ë–ª–æ–∫–∏—Ä—É–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –¥–µ–ª–∞—è –Ω–µ–≤–æ–∑–º–æ–∂–Ω—ã–º –≤—Ö–æ–¥ –≤ —Å–∏—Å—Ç–µ–º—É
admin.unban.user.sum=–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
admin.unban.user.desc=–°–Ω–∏–º–∞–µ—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∫—É –∏ –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –¥–æ—Å—Ç—É–ø –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
admin.promote.user.sum=–ü–æ–≤—ã—Å–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
admin.promote.user.desc=–ü—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Ä–æ–ª—å –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞
admin.demote.user.sum=–ü–æ–Ω–∏–∑–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
admin.demote.user.desc=–ó–∞–±–∏—Ä–∞–µ—Ç —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Ä–æ–ª—å –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞
admin.delete.user.sum=–£–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
admin.delete.user.desc=–ü–æ–º–µ—á–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∫–∞–∫ —É–¥–∞–ª—ë–Ω–Ω–æ–≥–æ, –¥–µ–ª–∞—è –µ–≥–æ –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã–º –≤ —Å–∏—Å—Ç–µ–º–µ
admin.create.admin.sum=–°–æ–∑–¥–∞—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
admin.create.admin.desc=–°–æ–∑–¥–∞—ë—Ç –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å —Ä–æ–ª—å—é –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä
admin.create.moder.sum=–°–æ–∑–¥–∞—Ç—å –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞
admin.create.moder.desc=–°–æ–∑–¥–∞—ë—Ç –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å —Ä–æ–ª—å—é –ú–æ–¥–µ—Ä–∞—Ç–æ—Ä

# === AppLogController OpenAPI ===
app.log.tag.name=–õ–æ–≥–∏
app.log.tag.desc=–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–æ–≤ –ª–æ–≥–æ–≤
app.log.get.all.logs.sum=–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ª–æ–≥–æ–≤
app.log.get.all.logs.desc=–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ª–æ–≥–æ–≤ —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π
app.log.get.by.user.sum=–ü–æ–ª—É—á–∏—Ç—å –ª–æ–≥–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
app.log.get.by.user.desc=–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ –ª–æ–≥–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ –ø–æ—á—Ç–µ

# === AuditController OpenAPI ===
audit.tag.name=–ê—É–¥–∏—Ç –¥–µ–π—Å—Ç–≤–∏–π
audit.tag.desc=–ü—Ä–æ—Å–º–æ—Ç—Ä –∂—É—Ä–Ω–∞–ª–æ–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π –≤ —Å–∏—Å—Ç–µ–º–µ
audit.get.all.audit.sum=–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∑–∞–ø–∏—Å–∏ –∞—É–¥–∏—Ç–∞
audit.get.all.audit.desc=–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∞—É–¥–∏—Ç–æ—Ä—Å–∫–∏—Ö –∑–∞–ø–∏—Å–µ–π —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
audit.get.by.admin.sum=–ü–æ–ª—É—á–∏—Ç—å –∞—É–¥–∏—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
audit.get.by.admin.desc=–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∂—É—Ä–Ω–∞–ª –¥–µ–π—Å—Ç–≤–∏–π, –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö –≤—ã–±—Ä–∞–Ω–Ω—ã–º –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º

# === AuthController OpenAPI ===
auth.tag.name=–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
auth.tag.desc=–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–æ–≤
auth.refresh.sum=–û–±–Ω–æ–≤–∏—Ç—å —Ç–æ–∫–µ–Ω –¥–æ—Å—Ç—É–ø–∞
auth.refresh.desc=–û–±–Ω–æ–≤–ª—è–µ—Ç –ø–∞—Ä—É —Ç–æ–∫–µ–Ω–æ–≤ (access –∏ refresh), –µ—Å–ª–∏ —Ç–µ–∫—É—â–∏–π refresh —Ç–æ–∫–µ–Ω –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω
auth.register.sum=–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
auth.register.desc=–°–æ–∑–¥–∞—ë—Ç –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –µ–≥–æ –¥–∞–Ω–Ω—ã–µ –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
auth.login.sum=–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
auth.login.desc=–ê–≤—Ç–æ—Ä–∏–∑—É–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ —É—á—ë—Ç–Ω—ã–º –¥–∞–Ω–Ω—ã–º –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ–∫–µ–Ω—ã –¥–æ—Å—Ç—É–ø–∞

# === ExpenseController OpenAPI ===
expense.tag.name=–†–∞—Å—Ö–æ–¥—ã
expense.tag.desc=–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏ –æ—Ç—á—ë—Ç–æ–≤ –ø–æ —Ä–∞—Å—Ö–æ–¥–∞–º
expense.report.sum=–ü–æ–ª—É—á–∏—Ç—å –æ—Ç—á—ë—Ç –ø–æ —Ä–∞—Å—Ö–æ–¥–∞–º
expense.report.desc=–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—Ç—á—ë—Ç –ø–æ –≤—Å–µ–º —Ä–∞—Å—Ö–æ–¥–∞–º –∑–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥ –≤—Ä–µ–º–µ–Ω–∏
expense.report.monthly.sum=–ü–æ–ª—É—á–∏—Ç—å –º–µ—Å—è—á–Ω—ã–π –æ—Ç—á—ë—Ç
expense.report.monthly.desc=–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—Ç—á—ë—Ç –ø–æ —Ä–∞—Å—Ö–æ–¥–∞–º –∑–∞ –≤—ã–±—Ä–∞–Ω–Ω—ã–π –º–µ—Å—è—Ü –∏ –≥–æ–¥
expense.get.total.sum=–ü–æ–ª—É—á–∏—Ç—å –æ–±—â—É—é —Å—É–º–º—É —Ä–∞—Å—Ö–æ–¥–æ–≤
expense.get.total.desc=–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—É–º–º–∞—Ä–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è

# === RecurringTransactionController OpenAPI ===
recurring.transaction.tag.name=–ü–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
recurring.transaction.tag.desc=–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–º–∏—Å—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
recurring.transaction.get.all.sum=–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
recurring.transaction.get.all.desc=–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
recurring.transaction.create.sum=–°–æ–∑–¥–∞—Ç—å –ø–æ–≤—Ç–æ—Ä—è—é—â—É—é—Å—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
recurring.transaction.create.desc=–°–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—É—é –ø–æ–≤—Ç–æ—Ä—è—é—â—É—é—Å—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
recurring.transaction.toggle.active.sum=–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
recurring.transaction.toggle.active.desc=–ê–∫—Ç–∏–≤–∏—Ä—É–µ—Ç –∏–ª–∏ –¥–µ–∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç –ø–æ–≤—Ç–æ—Ä—è—é—â—É—é—Å—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –ø–æ –µ—ë –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É

# === UserController OpenAPI ===
user.tag.name=–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏
user.tag.desc=–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ª–∏—á–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å—é —É—á—ë—Ç–Ω–æ–π –∑–∞–ø–∏—Å–∏
user.get.current.user.sum=–ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–µ–∫—É—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
user.get.current.user.desc=–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∏ –∞–¥—Ä–µ—Å —ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω–æ–π –ø–æ—á—Ç—ã)
user.change.password.sum=–°–º–µ–Ω–∏—Ç—å –ø–∞—Ä–æ–ª—å
user.change.password.desc=–ò–∑–º–µ–Ω—è–µ—Ç –ø–∞—Ä–æ–ª—å –ø—Ä–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–º –≤–≤–æ–¥–µ —Ç–µ–∫—É—â–µ–≥–æ

package com.example.expensetracker;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest(
        properties = {
                "spring.profiles.active=test",
                "spring.liquibase.enabled=true"
        })
class ExpenseTrackerApplicationTests {

    @Test
    void contextLoads() {
        // –µ—Å–ª–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç –Ω–µ —É–ø–∞–ª, —Ç–æ —Ç–µ—Å—Ç –±—É–¥–µ—Ç –∑–µ–ª—ë–Ω—ã–π
    }
}

package simulations;

import io.gatling.javaapi.core.ScenarioBuilder;
import io.gatling.javaapi.core.Simulation;
import io.gatling.javaapi.http.HttpProtocolBuilder;

import java.util.UUID;

import static io.gatling.javaapi.core.CoreDsl.*;
import static io.gatling.javaapi.http.HttpDsl.http;
import static io.gatling.javaapi.http.HttpDsl.status;

public class ExpenseTrackerSimulation extends Simulation {

    HttpProtocolBuilder httpProtocol = http
            .baseUrl("http://localhost:8080/api")
            .acceptHeader("application/json")
            .contentTypeHeader("application/json");

    ScenarioBuilder scn = scenario("Register -> Login -> Total -> Report (date range) -> Report (monthly)")
            .exec(session -> session
                    .set("randomEmail", "load-" + UUID.randomUUID() + "@example.com")
                    .set("randomName", "user-" + System.currentTimeMillis())
                    .set("dateFrom", "2025-11-01T00:00:00Z")
                    .set("dateTo", "2025-11-02T23:59:59Z")
                    .set("month", "NOVEMBER")
                    .set("year", 2025))
            .exec(http("registerUser")
                    .post("/auth/register")
                    .body(StringBody("{ \"email\": \"#{randomEmail}\", \"password\": \"123456\", \"name\": \"#{randomName}\" }"))
                    .check(status().is(201)))
            .exec(http("loginUser")
                    .post("/auth/login")
                    .body(StringBody("{ \"email\": \"#{randomEmail}\", \"password\": \"123456\" }"))
                    .check(status().is(200))
                    .check(jsonPath("$.data.accessToken").saveAs("jwtToken")))
            .exitHereIfFailed()
            .exec(http("getTotal")
                    .get("/expenses/total")
                    .header("Authorization", "Bearer #{jwtToken}")
                    .check(status().is(200)))
            .exec(http("getReport")
                    .get("/expenses/report?from=#{dateFrom}&to=#{dateTo}")
                    .header("Authorization", "Bearer #{jwtToken}")
                    .check(status().is(200)))
            .exec(http("reportMonthly")
                    .get("/expenses/stats/monthly?month=#{month}&year=#{year}")
                    .header("Authorization", "Bearer #{jwtToken}")
                    .check(status().is(200)))
            .pause(1, 3);

    {
        setUp(scn.injectOpen(rampUsers(100).during(60))).protocols(httpProtocol);
    }
}

package test.config;

import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.TestContext;
import org.springframework.test.context.TestExecutionListener;

/**
 * –ü–æ–ª–Ω–æ—Å—Ç—å—é –æ—á–∏—â–∞–µ—Ç –≤—Å–µ —Ç–∞–±–ª–∏—Ü—ã –ø–µ—Ä–µ–¥ –∫–∞–∂–¥—ã–º —Ç–µ—Å—Ç–æ–º.
 * –†–∞–±–æ—Ç–∞–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–ª—è –≤—Å–µ—Ö —Ç–µ—Å—Ç–æ–≤ —Å @SpringBootTest.
 */
public class DatabaseCleanupListener implements TestExecutionListener {

    @Override
    public void beforeTestMethod(TestContext testContext) throws Exception {
        JdbcTemplate jdbcTemplate = testContext.getApplicationContext().getBean(JdbcTemplate.class);
        cleanDB(jdbcTemplate);
    }
    
    private void cleanDB(JdbcTemplate jdbcTemplate) {
        jdbcTemplate.execute("""
                DO $$
                    DECLARE
                    r RECORD;
                    BEGIN
                FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP
                EXECUTE format('TRUNCATE TABLE %I CASCADE', r.tablename);
                END LOOP;
                END; $$
                """);
    }
}

package test.config;

import com.example.expensetracker.config.DataSeeder;
import com.example.expensetracker.model.Role;
import com.example.expensetracker.model.User;
import com.example.expensetracker.repository.UserRepository;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class DataSeederTest {
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private PasswordEncoder encoder;
    
    @InjectMocks
    private DataSeeder dataSeeder;
    
    private final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
    private final PrintStream originalOut = System.out;
    
    private final String ADMIN_EMAIL_SEEDER = "admin@example.com";
    private final String ADMIN_PASSWORD_SEEDER = "admin";
    private final String CREATED_PREFIX = "–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä —Å–æ–∑–¥–∞–Ω: –ø–æ—á—Ç–∞=";
    private final String EXISTS_PREFIX = "–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç";
    
    @BeforeEach
    void setUp() throws Exception {
        System.setOut(new PrintStream(byteArrayOutputStream));
        byteArrayOutputStream.reset();
        
        var email = DataSeeder.class.getDeclaredField("adminEmail");
        email.setAccessible(true);
        email.set(dataSeeder, ADMIN_EMAIL_SEEDER);
        var password = DataSeeder.class.getDeclaredField("adminPassword");
        password.setAccessible(true);
        password.set(dataSeeder, ADMIN_PASSWORD_SEEDER);
    }
    
    @AfterEach
    void cleanUpStreams() {
        System.setOut(originalOut);
    }
    
    @Test
    void run_shouldCreateAdmin_whenNotExist() throws Exception {
        when(userRepository.findByEmail(ADMIN_EMAIL_SEEDER)).thenReturn(Optional.empty());
        when(encoder.encode(ADMIN_PASSWORD_SEEDER)).thenReturn("encoded-password");
        
        dataSeeder.run();
        
        assertThat(byteArrayOutputStream.toString()).startsWith(CREATED_PREFIX);
        verify(userRepository).findByEmail(ADMIN_EMAIL_SEEDER);
        verify(encoder).encode(ADMIN_PASSWORD_SEEDER);
        ArgumentCaptor<User> userCaptor = ArgumentCaptor.forClass(User.class);
        verify(userRepository).save(userCaptor.capture());
        User savedUser = userCaptor.getValue();
        assertThat(savedUser.getEmail()).isEqualTo(ADMIN_EMAIL_SEEDER);
        assertThat(savedUser.getPassword()).isEqualTo("encoded-password");
        assertThat(savedUser.getRoles()).containsExactlyInAnyOrder(Role.ADMIN);
        verify(userRepository).save(any());
        verifyNoMoreInteractions(userRepository, encoder);
    }

    @Test
    void run_shouldPrintMessageInConsole_whenAdminAlreadyExist() throws Exception {
        when(userRepository.findByEmail(ADMIN_EMAIL_SEEDER)).thenReturn(Optional.of(new User()));

        dataSeeder.run();

        assertThat(byteArrayOutputStream.toString()).startsWith(EXISTS_PREFIX);
        verify(userRepository).findByEmail(ADMIN_EMAIL_SEEDER);
        verify(encoder, never()).encode(any());
        verify(userRepository, never()).save(any());
    }
}

package test.controller;

import com.example.expensetracker.ExpenseTrackerApplication;
import com.example.expensetracker.dto.RegisterDto;
import com.example.expensetracker.logging.audit.AuditRepository;
import com.example.expensetracker.model.Role;
import com.example.expensetracker.model.User;
import com.example.expensetracker.repository.UserRepository;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import test.security.WithMockCustomUser;

import static org.assertj.core.api.AssertionsForInterfaceTypes.assertThat;
import static org.hamcrest.Matchers.hasItem;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static test.util.Constants.*;
import static test.util.TestUtils.createAndSaveUser;

@SpringBootTest(classes = {ExpenseTrackerApplication.class},
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
@AutoConfigureMockMvc
public class AdminControllerIT {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private AuditRepository auditRepository;

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private MessageSource messageSource;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void getAllUsers_shouldReturnListUsers_whenUsersExist() throws Exception {
        createAndSaveUser(USER_EMAIL, Role.USER, userRepository);
        mockMvc.perform(get(API_ADMIN_USERS)
                        .param("page", "0")
                        .param("size", "10"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("get.all.users")))
                .andExpect(jsonPath("$.data.content").isArray())
                .andExpect(jsonPath("$.data.content[*].email").value(hasItem(USER_EMAIL)));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void getUserById_shouldReturnUser_whenUserExists() throws Exception {
        User user = createAndSaveUser(USER_EMAIL, Role.USER, userRepository);
        mockMvc.perform(get("/api/admin/users/{id}", user.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("get.user.by.id")))
                .andExpect(jsonPath("$.path").value(API_ADMIN_USERS + "/" + user.getId()))
                .andExpect(jsonPath("$.data.id").value(user.getId()))
                .andExpect(jsonPath("$.data.email").value(user.getEmail()));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void getUserById_shouldThrowException_whenUserNotExists() throws Exception {
        mockMvc.perform(get("/api/admin/users/{id}", ID_INVALID))
                .andExpect(status().isNotFound())
                .andDo(print())
                .andExpect(jsonPath("$.message").value(msg("handle.user.not.found.by.id")))
                .andExpect(jsonPath("$.path").value(API_ADMIN_USERS + "/" + ID_INVALID));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void getUserById_shouldThrowException_whenIdInvalid() throws Exception {
        mockMvc.perform(get("/api/admin/users/{id}", -1L))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").exists())
                .andExpect(jsonPath("$.path").value(API_ADMIN_USERS + "/-1"));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void banUser_shouldUserBanned_whenUserExists() throws Exception {
        createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        User user = createAndSaveUser(USER_EMAIL, Role.USER, userRepository);
        mockMvc.perform(put("/api/admin/users/{id}/ban", user.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("ban.user")))
                .andExpect(jsonPath("$.path").value(API_ADMIN_USERS + "/" + user.getId() + "/ban"))
                .andExpect(jsonPath("$.data").isNotEmpty());
        assertThat(auditRepository.findAll()).isNotEmpty();
        assertThat(userRepository.findById(user.getId()).get().isBanned()).isTrue();
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void banUser_shouldReturnUser_whenUserAlreadyBanned() throws Exception {
        createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        User user = createAndSaveUser(USER_EMAIL, Role.USER, userRepository);
        user.setBanned(true);
        userRepository.save(user);
        mockMvc.perform(put("/api/admin/users/{id}/ban", user.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("ban.user")))
                .andExpect(jsonPath("$.path").value(API_ADMIN_USERS + "/" + user.getId() + "/ban"))
                .andExpect(jsonPath("$.data.email").value(user.getEmail()));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void banUser_shouldThrowException_whenIdMatches() throws Exception {
        User user = createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        mockMvc.perform(put("/api/admin/users/{id}/ban", user.getId()))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.error").value("IllegalArgumentException"))
                .andExpect(jsonPath("$.message").value(msg("handle.illegal.argument")))
                .andExpect(jsonPath("$.path").value(API_ADMIN_USERS + "/" + user.getId() + "/ban"));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void banUser_shouldThrowException_whenUserNotExists() throws Exception {
        createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        mockMvc.perform(put("/api/admin/users/{id}/ban", ID_INVALID))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.message").value(msg("handle.entity.not.found")));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void unbanUser_shouldUserUnbanned_whenUserExists() throws Exception {
        createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        User user = createAndSaveUser(USER_EMAIL, Role.USER, userRepository);
        user.setBanned(true);
        userRepository.save(user);
        mockMvc.perform(put("/api/admin/users/{id}/unban", user.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("unban.user")))
                .andExpect(jsonPath("$.path").value(API_ADMIN_USERS + "/" + user.getId() + "/unban"))
                .andExpect(jsonPath("$.data").isNotEmpty());
        assertThat(auditRepository.findAll()).isNotEmpty();
        assertThat(userRepository.findById(user.getId()).get().isBanned()).isFalse();
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void unbanUser_shouldReturnUser_whenUserAlreadyUnbanned() throws Exception {
        createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        User user = createAndSaveUser(USER_EMAIL, Role.USER, userRepository);
        user.setBanned(false);
        userRepository.save(user);
        mockMvc.perform(put("/api/admin/users/{id}/unban", user.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("unban.user")))
                .andExpect(jsonPath("$.path").value(API_ADMIN_USERS + "/" + user.getId() + "/unban"))
                .andExpect(jsonPath("$.data.email").value(user.getEmail()));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void unbanUser_shouldReturnNotFound_whenUserNotExists() throws Exception {
        createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        mockMvc.perform(put("/api/admin/users/{id}/unban", ID_INVALID))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.message").value(msg("handle.entity.not.found")));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void unbanUser_shouldReturnNotFound_whenCurrentUserNotExists() throws Exception {
        mockMvc.perform(put("/api/admin/users/{id}/unban", ID_INVALID))
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.message").value(msg("handle.username.not.found")));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void promoteUser_shouldAddRoleModerator_whenUserExists() throws Exception {
        createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        User user = createAndSaveUser(USER_EMAIL, Role.USER, userRepository);
        mockMvc.perform(put("/api/admin/users/{id}/promote", user.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("promote.user")))
                .andExpect(jsonPath("$.path").value(API_ADMIN_USERS + "/" + user.getId() + "/promote"))
                .andExpect(jsonPath("$.data").isNotEmpty());
        assertThat(auditRepository.findAll()).isNotEmpty();
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void promoteUser_shouldReturnNotFound_whenUserNotExists() throws Exception {
        createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        mockMvc.perform(put("/api/admin/users/{id}/promote", ID_INVALID))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.message").value(msg("handle.entity.not.found")));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void promoteUser_shouldReturnUser_whenUserRoleAlreadyPromoted() throws Exception {
        createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        User user = createAndSaveUser(MODERATOR_EMAIL, Role.MODERATOR, userRepository);
        mockMvc.perform(put("/api/admin/users/{id}/promote", user.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("promote.user")))
                .andExpect(jsonPath("$.path").value(API_ADMIN_USERS + "/" + user.getId() + "/promote"))
                .andExpect(jsonPath("$.data.email").value(user.getEmail()));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void demoteUser_shouldAddRoleModerator_whenUserExists() throws Exception {
        createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        User user = createAndSaveUser(USER_EMAIL, Role.MODERATOR, userRepository);
        mockMvc.perform(put("/api/admin/users/{id}/demote", user.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("demote.user")))
                .andExpect(jsonPath("$.path").value(API_ADMIN_USERS + "/" + user.getId() + "/demote"))
                .andExpect(jsonPath("$.data").isNotEmpty());
        assertThat(auditRepository.findAll()).isNotEmpty();
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void demoteUser_shouldReturnNotFound_whenUserNotExists() throws Exception {
        createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        mockMvc.perform(put("/api/admin/users/{id}/demote", ID_INVALID))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.message").value(msg("handle.entity.not.found")));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void demoteUser_shouldReturnUser_whenRoleAlreadyDemoted() throws Exception {
        createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        User user = createAndSaveUser(USER_EMAIL, Role.USER, userRepository);
        mockMvc.perform(put(API_ADMIN_USERS + "/{id}/demote", user.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("demote.user")))
                .andExpect(jsonPath("$.path").value(API_ADMIN_USERS + "/" + user.getId() + "/demote"))
                .andExpect(jsonPath("$.data.email").value(user.getEmail()));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void deleteUser_shouldUserDelete_whenUserExists() throws Exception {
        createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        User user = createAndSaveUser(USER_EMAIL, Role.USER, userRepository);
        mockMvc.perform(delete("/api/admin/users/{id}/delete", user.getId()))
                .andExpect(status().isOk());
        assertThat(auditRepository.findAll()).isNotEmpty();
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void deleteUser_shouldThrowException_whenCurrentUserNotExists() throws Exception {
        User user = createAndSaveUser(USER_EMAIL, Role.USER, userRepository);
        mockMvc.perform(delete("/api/admin/users/{id}/delete", user.getId()))
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.message").value(msg("handle.username.not.found")));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void deleteUser_shouldThrowException_whenIdMatches() throws Exception {
        User user = createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        mockMvc.perform(delete("/api/admin/users/{id}/delete", user.getId()))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.error").value("IllegalArgumentException"))
                .andExpect(jsonPath("$.message").value(msg("handle.illegal.argument")))
                .andExpect(jsonPath("$.path").value(API_ADMIN_USERS + "/" + user.getId() + "/delete"));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void deleteUser_shouldReturnNotFound_whenUserNotExists() throws Exception {
        createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        mockMvc.perform(delete("/api/admin/users/{id}/delete", ID_INVALID))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.message").value(msg("handle.entity.not.found")));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void createAdmin_shouldCreateAdmin_whenEmailNotBusy() throws Exception {
        createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        String jsonBody = getJsonBody(USER_NAME, "new" + ADMIN_EMAIL, USER_PASSWORD);
        mockMvc.perform(post(API_ADMIN_USERS_CREATE_ADMINISTRATOR)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(jsonBody))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("create.admin")))
                .andExpect(jsonPath("$.path").value(API_ADMIN_USERS_CREATE_ADMINISTRATOR));
        assertThat(auditRepository.findAll()).isNotEmpty();
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void createAdmin_shouldThrowException_whenCurrentUserNotExists() throws Exception {
        String jsonBody = getJsonBody(USER_NAME, "new" + ADMIN_EMAIL, USER_PASSWORD);
        mockMvc.perform(post(API_ADMIN_USERS_CREATE_ADMINISTRATOR)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(jsonBody))
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.message").value(msg("handle.username.not.found")));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void createAdmin_shouldThrowException_whenAdminAlreadyExists() throws Exception {
        createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        createAndSaveUser("new" + ADMIN_EMAIL, Role.ADMIN, userRepository);
        String jsonBody = getJsonBody(USER_NAME, "new" + ADMIN_EMAIL, USER_PASSWORD);
        mockMvc.perform(post(API_ADMIN_USERS_CREATE_ADMINISTRATOR)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(jsonBody))
                .andExpect(status().isConflict())
                .andExpect(jsonPath("$.message").value(msg("handle.entity.exists")));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void createAdmin_shouldThrowException_whenNameIsEmpty() throws Exception {
        String json = getJsonBody("", ADMIN_EMAIL, USER_PASSWORD);
        mockMvc.perform(post(API_ADMIN_USERS_CREATE_ADMINISTRATOR)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(json))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(msg("user.name.not-blank")));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void createAdmin_shouldThrowException_whenEmailIsEmpty() throws Exception {
        String json = getJsonBody(USER_NAME, "", USER_PASSWORD);
        mockMvc.perform(post(API_ADMIN_USERS_CREATE_ADMINISTRATOR)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(json))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(msg("user.email.not-blank")));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void createAdmin_shouldThrowException_whenEmailInvalid() throws Exception {
        String json = getJsonBody(USER_NAME, "not-email", USER_PASSWORD);
        mockMvc.perform(post(API_ADMIN_USERS_CREATE_ADMINISTRATOR)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(json))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(msg("user.email.invalid")));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void createAdmin_shouldThrowException_whenPasswordIsEmpty() throws Exception {
        String json = getJsonBody(USER_NAME, ADMIN_EMAIL, "");
        mockMvc.perform(post(API_ADMIN_USERS_CREATE_ADMINISTRATOR)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(json))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(msg("user.password.not-blank")));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void createModer_shouldCreateModer_whenEmailNotBusy() throws Exception {
        createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        String jsonBody = getJsonBody(USER_NAME, MODERATOR_EMAIL, USER_PASSWORD);
        mockMvc.perform(post(API_ADMIN_USERS_CREATE_MODERATOR)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(jsonBody))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("create.moder")))
                .andExpect(jsonPath("$.path").value(API_ADMIN_USERS_CREATE_MODERATOR));
        assertThat(auditRepository.findAll()).isNotEmpty();
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void createModer_shouldThrowException_whenCurrentUserNotExists() throws Exception {
        String jsonBody = getJsonBody(USER_NAME, "new" + MODERATOR_EMAIL, USER_PASSWORD);
        mockMvc.perform(post(API_ADMIN_USERS_CREATE_MODERATOR)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(jsonBody))
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.message").value(msg("handle.username.not.found")));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void createModer_shouldThrowException_whenAdminAlreadyExists() throws Exception {
        createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        createAndSaveUser(MODERATOR_EMAIL, Role.MODERATOR, userRepository);
        String jsonBody = getJsonBody(USER_NAME, MODERATOR_EMAIL, USER_PASSWORD);
        mockMvc.perform(post(API_ADMIN_USERS_CREATE_MODERATOR)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(jsonBody))
                .andExpect(status().isConflict())
                .andExpect(jsonPath("$.message").value(msg("handle.entity.exists")));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void createModer_shouldThrowException_whenNameIsEmpty() throws Exception {
        String json = getJsonBody("", MODERATOR_EMAIL, USER_PASSWORD);
        mockMvc.perform(post(API_ADMIN_USERS_CREATE_MODERATOR)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(json))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(msg("user.name.not-blank")));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void createModer_shouldThrowException_whenEmailIsEmpty() throws Exception {
        String json = getJsonBody(USER_NAME, "", USER_PASSWORD);
        mockMvc.perform(post(API_ADMIN_USERS_CREATE_MODERATOR)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(json))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(msg("user.email.not-blank")));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void createModer_shouldThrowException_whenEmailInvalid() throws Exception {
        String json = getJsonBody(USER_NAME, "not-email", USER_PASSWORD);
        mockMvc.perform(post(API_ADMIN_USERS_CREATE_MODERATOR)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(json))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(msg("user.email.invalid")));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void createModer_shouldThrowException_whenPasswordIsEmpty() throws Exception {
        String json = getJsonBody(USER_NAME, MODERATOR_EMAIL, "");
        mockMvc.perform(post(API_ADMIN_USERS_CREATE_MODERATOR)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(json))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(msg("user.password.not-blank")));
    }

    private String getJsonBody(String name, String email, String password) throws JsonProcessingException {
        return objectMapper.writeValueAsString(new RegisterDto(name, email, password));
    }

    private String msg(String key) {
        return messageSource.getMessage(key, null, LocaleContextHolder.getLocale());
    }
}

package test.controller;

import com.example.expensetracker.ExpenseTrackerApplication;
import com.example.expensetracker.logging.applog.AppLogService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import test.security.WithMockCustomUser;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static test.util.Constants.ADMIN_EMAIL;

@SpringBootTest(classes = {ExpenseTrackerApplication.class},
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
@AutoConfigureMockMvc
public class AppLogControllerIT {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private MessageSource messageSource;

    @Autowired
    private AppLogService appLogService;

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void getAllLogs_shouldReturnListLogs_whenLogsExist() throws Exception {
        mockMvc.perform(get("/api/admin/logs"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("app.log.controller.logs.get.all")))
                .andExpect(jsonPath("$.path").value("/api/admin/logs"))
                .andExpect(jsonPath("$.data.content").isArray());
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void getByUser_shouldReturnListLogs_whenUserExist() throws Exception {
        mockMvc.perform(get("/api/admin/logs/user/{email}", ADMIN_EMAIL))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("app.log.controller.logs.get.by.user")))
                .andExpect(jsonPath("$.path").value("/api/admin/logs/user/" + ADMIN_EMAIL))
                .andExpect(jsonPath("$.data.content").isArray());
    }

    private String msg(String key) {
        return messageSource.getMessage(key, null, LocaleContextHolder.getLocale());
    }
}

package test.controller;

import com.example.expensetracker.ExpenseTrackerApplication;
import com.example.expensetracker.logging.audit.AuditAction;
import com.example.expensetracker.logging.audit.AuditRepository;
import com.example.expensetracker.logging.audit.AuditService;
import com.example.expensetracker.model.Role;
import com.example.expensetracker.model.User;
import com.example.expensetracker.repository.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import test.security.WithMockCustomUser;
import test.util.TestData;

import java.util.Set;
import java.util.UUID;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static test.util.Constants.ADMIN_EMAIL;
import static test.util.Constants.USER_PASSWORD;

@SpringBootTest(classes = {ExpenseTrackerApplication.class},
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
@AutoConfigureMockMvc
public class AuditControllerIT {

    @Autowired
    private MessageSource messageSource;

    @Autowired
    private AuditService auditService;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private AuditRepository auditRepository;

    private String email1;
    private String email2;

    @BeforeEach
    void setUp() {
        auditRepository.deleteAll();
        userRepository.deleteAll();
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void getAllAudit_shouldReturnListLogs_whenLogsExist() throws Exception {
        email1 = UUID.randomUUID() + "@example.com";
        email2 = UUID.randomUUID() + "@example.com";
        User admin = TestData.user(null, email1, USER_PASSWORD, Set.of(Role.ADMIN), false);
        User user = TestData.user(null, email2, USER_PASSWORD, Set.of(Role.USER), false);
        userRepository.save(admin);
        userRepository.save(user);
        auditService.logAction(AuditAction.BAN, user, admin);
        mockMvc.perform(get("/api/admin/audit"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("audit.controller.get.all")))
                .andExpect(jsonPath("$.path").value("/api/admin/audit"))
                .andExpect(jsonPath("$.data.content").isArray());
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void getByAdmin_shouldReturnListLogs_whenAdminExists() throws Exception {
        email1 = UUID.randomUUID() + "@example.com";
        email2 = UUID.randomUUID() + "@example.com";
        User admin = TestData.user(null, email1, USER_PASSWORD, Set.of(Role.ADMIN), false);
        User moderator = TestData.user(null, email2, USER_PASSWORD, Set.of(Role.MODERATOR), false);
        userRepository.save(admin);
        userRepository.save(moderator);
        auditService.logAction(AuditAction.CREATE, moderator, admin);
        mockMvc.perform(get("/api/admin/audit/{id}", admin.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("audit.controller.get.by.admin")))
                .andExpect(jsonPath("$.path").value("/api/admin/audit/" + admin.getId()))
                .andExpect(jsonPath("$.data.content").isArray());
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void getAllAudit_shouldReturnListLogs_whenSortedSuccess() throws Exception {
        email1 = UUID.randomUUID() + "@example.com";
        email2 = UUID.randomUUID() + "@example.com";
        User admin = TestData.user(null, email1, USER_PASSWORD, Set.of(Role.ADMIN), false);
        User user = TestData.user(null, email2, USER_PASSWORD, Set.of(Role.USER), false);
        userRepository.save(admin);
        userRepository.save(user);
        auditService.logAction(AuditAction.BAN, user, admin);
        Thread.sleep(100);
        auditService.logAction(AuditAction.UNBAN, user, admin);
        mockMvc.perform(get("/api/admin/audit"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("audit.controller.get.all")))
                .andExpect(jsonPath("$.path").value("/api/admin/audit"))
                .andExpect(jsonPath("$.data.content[0].action").value("UNBAN"));
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void getByAdmin_shouldReturnListLogs_whenSortedSuccess() throws Exception {
        email1 = UUID.randomUUID() + "@example.com";
        email2 = UUID.randomUUID() + "@example.com";
        User admin = TestData.user(null, email1, USER_PASSWORD, Set.of(Role.ADMIN), false);
        User moderator = TestData.user(null, email2, USER_PASSWORD, Set.of(Role.MODERATOR), false);
        userRepository.save(admin);
        userRepository.save(moderator);
        auditService.logAction(AuditAction.CREATE, moderator, admin);
        Thread.sleep(100);
        auditService.logAction(AuditAction.DELETE, moderator, admin);
        mockMvc.perform(get("/api/admin/audit/{id}", admin.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("audit.controller.get.by.admin")))
                .andExpect(jsonPath("$.path").value("/api/admin/audit/" + admin.getId()))
                .andExpect(jsonPath("$.data.content[0].action").value("DELETE"));
    }

    private String msg(String key) {
        return messageSource.getMessage(key, null, LocaleContextHolder.getLocale());
    }
}

package test.controller;

import com.example.expensetracker.controller.AuditController;
import com.example.expensetracker.logging.audit.AuditDto;
import com.example.expensetracker.logging.audit.AuditService;
import jakarta.servlet.http.HttpServletRequest;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.context.MessageSource;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import test.util.TestData;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.*;
import static test.util.Constants.ID_INVALID;
import static test.util.Constants.ID_VALID;

@ExtendWith(MockitoExtension.class)
public class AuditControllerTest {

    @Mock
    private AuditService auditService;

    @Mock
    private Pageable pageable;

    @Mock
    private HttpServletRequest request;

    @Mock
    private MessageSource messageSource;

    @InjectMocks
    private AuditController auditController;

    @BeforeEach
    void setUp() {
        when(messageSource.getMessage(anyString(), any(), any())).thenAnswer(invocation ->
                invocation.getArgument(0));
    }

    @Test
    public void getAllAudit_shouldReturnListOfLogs() {
        Page<AuditDto> logs = new PageImpl<>(List.of());
        when(auditService.getAll(any())).thenReturn(logs);

        var result = auditController.getAllAudit(pageable, request);
        
        assertThat(result).isNotNull();
        assertThat(result.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(result.getBody()).isNotNull();
        assertThat(result.getBody().getData()).isEqualTo(logs);
        verify(auditService, times(1)).getAll(any());
        verify(messageSource).getMessage(eq("audit.controller.get.all"), isNull(), any());
    }

    @Test
    public void getAllAudit_shouldReturnEmptyList_whenNoLogs() {
        Page<AuditDto> logs = new PageImpl<>(List.of());
        when(auditService.getAll(any())).thenReturn(logs);

        var result = auditController.getAllAudit(pageable, request);
        
        assertThat(result).isNotNull();
        assertThat(result.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(result.getBody()).isNotNull();
        assertThat(result.getBody().getData()).isEmpty();
        verify(auditService, times(1)).getAll(any());
        verify(messageSource).getMessage(eq("audit.controller.get.all"), isNull(), any());
    }

    @Test
    public void getByAdmin_shouldReturnListOfLogs() {
        Page<AuditDto> logs = new PageImpl<>(List.of());
        when(auditService.getByAdmin(anyLong(), any())).thenReturn(logs);

        var result = auditController.getByAdmin(ID_VALID, pageable, request);

        assertThat(result).isNotNull();
        assertThat(result.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(result.getBody()).isNotNull();
        assertThat(result.getBody().getData()).isEqualTo(logs);
        verify(auditService, times(1)).getByAdmin(eq(ID_VALID), any());
        verify(messageSource).getMessage(eq("audit.controller.get.by.admin"), isNull(), any());
    }

    @Test
    public void getByAdmin_shouldReturnEmptyList_whenNoLogs() {
        Page<AuditDto> logs = new PageImpl<>(List.of());
        when(auditService.getByAdmin(anyLong(), any())).thenReturn(logs);

        var result = auditController.getByAdmin(ID_INVALID, pageable, request);

        assertThat(result).isNotNull();
        assertThat(result.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(result.getBody()).isNotNull();
        assertThat(result.getBody().getData()).isEmpty();
        verify(auditService, times(1)).getByAdmin(eq(ID_INVALID), any());
        verify(messageSource).getMessage(eq("audit.controller.get.by.admin"), isNull(), any());
    }
}

package test.controller;

import com.example.expensetracker.ExpenseTrackerApplication;
import com.example.expensetracker.dto.LoginRequest;
import com.example.expensetracker.dto.RegisterDto;
import com.example.expensetracker.repository.UserRepository;
import com.example.expensetracker.security.JwtUtil;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;

import java.util.Map;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static test.util.Constants.*;
import static test.util.TestMessageSource.msg;

@SpringBootTest(classes = {ExpenseTrackerApplication.class},
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
@AutoConfigureMockMvc
public class AuthControllerIT {

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private UserRepository userRepository;

    private String name;
    private String email;
    private String password;

    @BeforeEach
    void setUp() {
        name = UUID.randomUUID().toString();
        email = "test-" + UUID.randomUUID() + "@example.com";
        password = USER_PASSWORD;
    }

    @Test
    void fullFlow_register_login_refresh() throws Exception {
        RegisterDto registerDto = new RegisterDto(USER_NAME, email, password);
        mockMvc.perform(post(API_AUTH_REGISTER)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(registerDto)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.data.email").value(email));

        LoginRequest loginRequest = new LoginRequest(email, password);
        String loginResponse = mockMvc.perform(post(API_AUTH_LOGIN)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(loginRequest)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.data.accessToken").isNotEmpty())
                .andExpect(jsonPath("$.data.refreshToken").isNotEmpty())
                .andReturn()
                .getResponse()
                .getContentAsString();
        String refreshToken = objectMapper.readTree(loginResponse).path("data").path("refreshToken").asText();
        assertThat(refreshToken).isNotBlank();

        String refreshBody = objectMapper.writeValueAsString(Map.of("refreshToken", refreshToken));
        mockMvc.perform(post(API_AUTH_REFRESH)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(refreshBody))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.data.accessToken").isNotEmpty())
                .andExpect(jsonPath("$.data.refreshToken").isNotEmpty());
    }

    @Test
    void register_shouldThrowException_whenUserAlreadyExist() throws Exception {
        RegisterDto registerDto = new RegisterDto(USER_NAME, email, password);
        mockMvc.perform(post(API_AUTH_REGISTER)
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(registerDto)));
        mockMvc.perform(post(API_AUTH_REGISTER)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(registerDto)))
                .andExpect(status().isConflict())
                .andExpect(jsonPath("$.message").value(msg("handle.data.integrity.violation")));
    }

    @Test
    void register_shouldThrowException_whenEmailIsEmpty() throws Exception {
        RegisterDto registerDto = new RegisterDto(USER_NAME, "", password);
        mockMvc.perform(post(API_AUTH_REGISTER)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(registerDto)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(msg("user.email.not-blank")));
    }

    @Test
    void login_shouldThrowException_whenUserNotFound() throws Exception {
        LoginRequest loginRequest = new LoginRequest(email, password);
        mockMvc.perform(post(API_AUTH_LOGIN)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(loginRequest)))
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.message").value(msg("handle.bad.credentials")));
    }

    @Test
    void login_shouldThrowException_whenPasswordInvalid() throws Exception {
        registerUser(name, email, password);

        LoginRequest loginRequest = new LoginRequest(email, "invalidPassword");
        mockMvc.perform(post(API_AUTH_LOGIN)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(loginRequest)))
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.message").value(msg("handle.bad.credentials")));
    }

    @Test
    void refresh_shouldThrowException_whenUserNotFound() throws Exception {
        String token = jwtUtil.generateRefreshToken(email);
        String refreshBody = objectMapper.writeValueAsString(Map.of("refreshToken", token));
        mockMvc.perform(post(API_AUTH_REFRESH)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(refreshBody))
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.message").value(msg("handle.username.not.found")));
    }

    @Test
    void refresh_shouldReturnForbidden_whenUserIsBanned() throws Exception {
        registerUser(name, email, password);
        userRepository.findByEmail(email).ifPresent(user -> {
            user.setBanned(true);
            userRepository.save(user);
        });
        String token = jwtUtil.generateRefreshToken(email);
        String refreshBody = objectMapper.writeValueAsString(Map.of("refreshToken", token));
        mockMvc.perform(post(API_AUTH_REFRESH)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(refreshBody))
                .andExpect(status().isForbidden())
                .andExpect(jsonPath("$.message").value(msg("handle.access.denied")));
    }

    @Test
    void refresh_shouldReturnUnauthorized_whenTokenInvalid() throws Exception {
        String refreshBody = objectMapper.writeValueAsString(Map.of("refreshToken", "invalidToken"));
        mockMvc.perform(post(API_AUTH_REFRESH)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(refreshBody))
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.message").value(msg("handle.bad.credentials")));
    }

    private void registerUser(String name, String email, String password) throws Exception {
        RegisterDto registerDto = new RegisterDto(name, email, password);
        mockMvc.perform(post(API_AUTH_REGISTER)
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(registerDto)));
    }
}

package test.controller;

import com.example.expensetracker.ExpenseTrackerApplication;
import com.example.expensetracker.model.Role;
import com.example.expensetracker.repository.UserRepository;
import com.example.expensetracker.service.ExpenseService;
import com.example.expensetracker.service.UserService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.MessageSource;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.security.test.context.support.TestExecutionEvent;
import org.springframework.security.test.context.support.WithUserDetails;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;

import static com.example.expensetracker.model.Month.SEPTEMBER;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static test.util.Constants.*;
import static test.util.TestMessageSource.msg;
import static test.util.TestUtils.createAndSaveUser;

@SpringBootTest(classes = {ExpenseTrackerApplication.class},
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
@AutoConfigureMockMvc
public class ExpenseControllerIT {

    @Autowired
    private MessageSource messageSource;

    @Autowired
    private UserService userService;

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Autowired
    private ObjectMapper objectMapper;

    @BeforeEach
    void setUp() {
        createAndSaveUser(USER_EMAIL, Role.USER, userRepository);
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void report_shouldReturnExpensesForPeriod() throws Exception {
        String from = "2025-09-01T00:00:00Z";
        String to = "2025-10-01T00:00:00Z";

        mockMvc.perform(get(API_EXPENSES_REPORT)
                        .param("from", from)
                        .param("to", to))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("expense.controller.report.ok")))
                .andExpect(jsonPath("$.path").value(API_EXPENSES_REPORT));
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void report_shouldReturnBadRequest_whenInvalidDates() throws Exception {
        String invalidFrom = "2026-09-01T00:00:00Z";
        String invalidTo = "2024-10-01T00:00:00Z";

        mockMvc.perform(get(API_EXPENSES_REPORT)
                        .param("from", invalidFrom)
                        .param("to", invalidTo))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(msg("date.range.dto.from.is.valid.range")));
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void getTotal_shouldReturnTotalExpenses() throws Exception {
        mockMvc.perform(get(API_EXPENSES_TOTAL))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("expense.controller.total.ok")))
                .andExpect(jsonPath("$.path").value(API_EXPENSES_TOTAL));
    }
    
    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void reportMonthly_shouldReturnTotalExpenses_whenAllFieldsValid() throws Exception {
        mockMvc.perform(get(API_EXPENSES_STATS_MONTHLY)
                        .param("month", SEPTEMBER.name())
                        .param("year", "2025"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("expense.controller.report.monthly")))
                .andExpect(jsonPath("$.path").value(API_EXPENSES_STATS_MONTHLY));
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void reportMonthly_shouldReturnBadRequest_whenMonthMissed() throws Exception {
        mockMvc.perform(get(API_EXPENSES_STATS_MONTHLY)
                        .param("year", "2025"))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(msg("handle.handler.method.validation")))
                .andExpect(jsonPath("$.path").value(API_EXPENSES_STATS_MONTHLY));
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void reportMonthly_shouldUseCurrentYear_whenYearMissed() throws Exception {
        mockMvc.perform(get(API_EXPENSES_STATS_MONTHLY)
                        .param("month", SEPTEMBER.name()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("expense.controller.report.monthly")))
                .andExpect(jsonPath("$.path").value(API_EXPENSES_STATS_MONTHLY));
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void reportMonthly_shouldReturnUnauthorized_whenUserNotFound() throws Exception {
        userRepository.deleteAll();
        mockMvc.perform(get(API_EXPENSES_STATS_MONTHLY)
                        .param("month", SEPTEMBER.name())
                        .param("year", "2025"))
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.message").value(msg("handle.username.not.found")));
    }
}

package test.controller;

import com.example.expensetracker.ExpenseTrackerApplication;
import com.example.expensetracker.logging.audit.AuditRepository;
import com.example.expensetracker.model.Role;
import com.example.expensetracker.model.User;
import com.example.expensetracker.repository.UserRepository;
import org.assertj.core.api.AssertionsForClassTypes;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.security.test.context.support.TestExecutionEvent;
import org.springframework.security.test.context.support.WithUserDetails;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;

import java.util.UUID;

import static org.assertj.core.api.AssertionsForInterfaceTypes.assertThat;
import static org.hamcrest.Matchers.hasItem;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static test.util.Constants.*;
import static test.util.TestUtils.createAndSaveUser;

@SpringBootTest(classes = {ExpenseTrackerApplication.class},
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
@AutoConfigureMockMvc
public class ModeratorControllerIT {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private AuditRepository auditRepository;

    @Autowired
    private MessageSource messageSource;

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    private String name = "newModer";
    private String email = UUID.randomUUID() + "@example.com";
    private String password = "pass";
    private Long idModerator;

    @BeforeEach
    void setUp() {
        User moderator = createAndSaveUser(MODERATOR_EMAIL, Role.MODERATOR, userRepository);
        idModerator = moderator.getId();
    }

    @Test
    @WithUserDetails(value = MODERATOR_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void getAllUsers_shouldReturnListUsers_whenUsersExist() throws Exception {
        createAndSaveUser(email, Role.USER, userRepository);
        mockMvc.perform(get(API_MODERATOR_USERS)
                        .param("page", "0")
                        .param("size", "10"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("get.all.users")))
                .andExpect(jsonPath("$.data.content").isArray())
                .andExpect(jsonPath("$.data.content[*].email").value(hasItem(email)));
    }

    @Test
    @WithUserDetails(value = MODERATOR_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void getUserById_shouldReturnUser_whenUserExists() throws Exception {
        User user = createAndSaveUser(email, Role.USER, userRepository);
        mockMvc.perform(get(API_MODERATOR_USERS + "/{id}", user.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("get.user.by.id")))
                .andExpect(jsonPath("$.path").value(userPath(user.getId())))
                .andExpect(jsonPath("$.data.id").value(user.getId()))
                .andExpect(jsonPath("$.data.email").value(user.getEmail()));
    }

    @Test
    @WithUserDetails(value = MODERATOR_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void getUserById_shouldThrowException_whenUserNotExists() throws Exception {
        mockMvc.perform(get(API_MODERATOR_USERS + "/{id}", ID_INVALID))
                .andExpect(status().isNotFound())
                .andDo(print())
                .andExpect(jsonPath("$.message").value(msg("handle.user.not.found.by.id")))
                .andExpect(jsonPath("$.path").value(userPath(ID_INVALID)));
    }

    @Test
    @WithUserDetails(value = MODERATOR_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void getUserById_shouldThrowException_whenIdInvalid() throws Exception {
        mockMvc.perform(get(API_MODERATOR_USERS + "/{id}", -1L))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value("–¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –±–æ–ª—å—à–µ 0"))
                .andExpect(jsonPath("$.path").value(userPath(-1L)));
    }

    @Test
    @WithUserDetails(value = MODERATOR_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void banUser_shouldUserBanned_whenUserExists() throws Exception {
        User user = createAndSaveUser(email, Role.USER, userRepository);
        mockMvc.perform(put(API_MODERATOR_USERS + "/{id}/ban", user.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("ban.user")))
                .andExpect(jsonPath("$.path").value(userPath(user.getId()) + "/ban"))
                .andExpect(jsonPath("$.data").isNotEmpty());
        assertThat(auditRepository.findAll()).isNotEmpty();
        AssertionsForClassTypes.assertThat(userRepository.findById(user.getId()).get().isBanned()).isTrue();
    }

    @Test
    @WithUserDetails(value = MODERATOR_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void banUser_shouldReturnOk_whenUserAlreadyBanned() throws Exception {
        User user = createAndSaveUser(email, Role.USER, userRepository);
        user.setBanned(true);
        userRepository.save(user);
        mockMvc.perform(put(API_MODERATOR_USERS + "/{id}/ban", user.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("ban.user")))
                .andExpect(jsonPath("$.path").value(userPath(user.getId()) + "/ban"))
                .andExpect(jsonPath("$.data").isNotEmpty());
        assertThat(auditRepository.findAll()).isEmpty();
        AssertionsForClassTypes.assertThat(userRepository.findById(user.getId()).get().isBanned()).isTrue();
    }

    @Test
    @WithUserDetails(value = MODERATOR_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void banUser_shouldThrowException_whenUserIsModer() throws Exception {
        User user = createAndSaveUser(email, Role.MODERATOR, userRepository);
        mockMvc.perform(put(API_MODERATOR_USERS + "/{id}/ban", user.getId()))
                .andExpect(status().isForbidden())
                .andExpect(jsonPath("$.message").value(msg("handle.access.denied")))
                .andExpect(jsonPath("$.path").value(userPath(user.getId()) + "/ban"));
    }

    @Test
    @WithUserDetails(value = MODERATOR_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void banUser_shouldThrowException_whenUserIsAdmin() throws Exception {
        User user = createAndSaveUser(email, Role.ADMIN, userRepository);
        mockMvc.perform(put(API_MODERATOR_USERS + "/{id}/ban", user.getId()))
                .andExpect(status().isForbidden())
                .andExpect(jsonPath("$.message").value(msg("handle.access.denied")))
                .andExpect(jsonPath("$.path").value(userPath(user.getId()) + "/ban"));
    }

    @Test
    @WithUserDetails(value = MODERATOR_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void banUser_shouldThrowException_whenIdMatches() throws Exception {
        mockMvc.perform(put(API_MODERATOR_USERS + "/{id}/ban", idModerator))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.error").value("IllegalArgumentException"))
                .andExpect(jsonPath("$.message").value(msg("handle.illegal.argument")))
                .andExpect(jsonPath("$.path").value(userPath(idModerator) + "/ban"));
    }

    @Test
    @WithUserDetails(value = MODERATOR_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void banUser_shouldThrowException_whenUserNotExists() throws Exception {
        mockMvc.perform(put(API_MODERATOR_USERS + "/{id}/ban", ID_INVALID))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.message").value(msg("handle.entity.not.found")));
    }

    @Test
    @WithUserDetails(value = MODERATOR_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void banUser_shouldThrowException_whenCurrentUserNotExists() throws Exception {
        userRepository.deleteAll();
        mockMvc.perform(put(API_MODERATOR_USERS + "/{id}/ban", ID_INVALID))
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.message").value(msg("handle.username.not.found")));
    }

    @Test
    @WithUserDetails(value = MODERATOR_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void unbanUser_shouldUserUnbanned_whenUserExists() throws Exception {
        User user = createAndSaveUser(email, Role.USER, userRepository);
        user.setBanned(true);
        userRepository.save(user);
        mockMvc.perform(put(API_MODERATOR_USERS + "/{id}/unban", user.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("unban.user")))
                .andExpect(jsonPath("$.path").value(userPath(user.getId()) + "/unban"))
                .andExpect(jsonPath("$.data").isNotEmpty());
        assertThat(auditRepository.findAll()).isNotEmpty();
        AssertionsForClassTypes.assertThat(userRepository.findById(user.getId()).get().isBanned()).isFalse();
    }

    @Test
    @WithUserDetails(value = MODERATOR_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void unbanUser_shouldReturnOk_whenUserAlreadyUnbanned() throws Exception {
        User user = createAndSaveUser(email, Role.USER, userRepository);
        user.setBanned(false);
        userRepository.save(user);
        mockMvc.perform(put(API_MODERATOR_USERS + "/{id}/unban", user.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("unban.user")))
                .andExpect(jsonPath("$.path").value(userPath(user.getId()) + "/unban"))
                .andExpect(jsonPath("$.data").isNotEmpty());
        assertThat(auditRepository.findAll()).isEmpty();
        AssertionsForClassTypes.assertThat(userRepository.findById(user.getId()).get().isBanned()).isFalse();
    }

    @Test
    @WithUserDetails(value = MODERATOR_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void unbanUser_shouldReturnNotFound_whenUserNotExists() throws Exception {
        mockMvc.perform(put(API_MODERATOR_USERS + "/{id}/unban", ID_INVALID))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.message").value(msg("handle.entity.not.found")));
    }

    @Test
    @WithUserDetails(value = MODERATOR_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void unbanUser_shouldThrowException_whenCurrentUserNotExists() throws Exception {
        userRepository.deleteAll();
        mockMvc.perform(put(API_MODERATOR_USERS + "/{id}/unban", ID_INVALID))
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.message").value(msg("handle.username.not.found")));
    }

    private String msg(String key) {
        return messageSource.getMessage(key, null, LocaleContextHolder.getLocale());
    }

    private String userPath(Long id) {
        return API_MODERATOR_USERS + "/" + id;
    }
}

package test.controller;

import com.example.expensetracker.ExpenseTrackerApplication;
import com.example.expensetracker.dto.RecurringTransactionRequestDto;
import com.example.expensetracker.model.Category;
import com.example.expensetracker.model.RecurringTransaction;
import com.example.expensetracker.model.Role;
import com.example.expensetracker.model.User;
import com.example.expensetracker.repository.CategoryRepository;
import com.example.expensetracker.repository.RecurringTransactionRepository;
import com.example.expensetracker.repository.UserRepository;
import com.example.expensetracker.service.RecurringTransactionService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.security.test.context.support.TestExecutionEvent;
import org.springframework.security.test.context.support.WithUserDetails;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;

import java.math.BigDecimal;
import java.time.LocalDate;

import static org.assertj.core.api.Assertions.assertThat;
import static org.hamcrest.Matchers.containsString;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static test.util.Constants.*;
import static test.util.TestMessageSource.msg;
import static test.util.TestUtils.createAndSaveUser;

@SpringBootTest(classes = {ExpenseTrackerApplication.class},
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
@AutoConfigureMockMvc
public class RecurringTransactionControllerIT {

    @Autowired
    private RecurringTransactionService recurringTransactionService;

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Autowired
    private RecurringTransactionRepository recurringTransactionRepository;

    @Autowired
    private CategoryRepository categoryRepository;

    User user;

    @BeforeEach
    void setUp() {
        user = createAndSaveUser(USER_EMAIL, Role.USER, userRepository);
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void getAll_shouldReturnEmptyList_whenNoTransactions() throws Exception {
        mockMvc.perform(get(API_RECURRING_TRANSACTION))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("recurring.transaction.controller.get.all")))
                .andExpect(jsonPath("$.path").value(API_RECURRING_TRANSACTION))
                .andExpect(jsonPath("$.data").isEmpty());
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void getAll_shouldReturnListRecurringTransaction_whenTransactionsExist() throws Exception {
        Category category = categoryRepository.save(new Category(CATEGORY_NAME));
        RecurringTransaction recurringTransaction = new RecurringTransaction(new BigDecimal(AMOUNT), DESCRIPTION,
                category, user, INTERVAL_DAYS, LocalDate.now().minusDays(1));
        recurringTransactionRepository.save(recurringTransaction);
        mockMvc.perform(get(API_RECURRING_TRANSACTION))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("recurring.transaction.controller.get.all")))
                .andExpect(jsonPath("$.path").value(API_RECURRING_TRANSACTION))
                .andExpect(jsonPath("$.data").isNotEmpty())
                .andExpect(jsonPath("$.data[0].categoryId").value(category.getId()));
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void getAll_shouldReturnNotFound_whenUserNotExists() throws Exception {
        userRepository.deleteAll();
        mockMvc.perform(get(API_RECURRING_TRANSACTION))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.message").value(msg("handle.user.not.found.by.id")));
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void create_shouldReturnSuccess_whenAllFieldsValid() throws Exception {
        Category category = categoryRepository.save(new Category(CATEGORY_NAME));
        RecurringTransactionRequestDto dto = new RecurringTransactionRequestDto(new BigDecimal(AMOUNT), DESCRIPTION,
                category.getId(), INTERVAL_DAYS);
        mockMvc.perform(post(API_RECURRING_TRANSACTION_CREATE)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("recurring.transaction.controller.create")))
                .andExpect(jsonPath("$.path").value(API_RECURRING_TRANSACTION_CREATE))
                .andExpect(jsonPath("$.data.amount").value(dto.amount()))
                .andExpect(jsonPath("$.data.categoryId").value(dto.categoryId()));
        assertThat(recurringTransactionRepository.findAll()).hasSize(1);
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void create_shouldReturnNotFound_whenUserNotExists() throws Exception {
        userRepository.delete(user);
        Category category = categoryRepository.save(new Category(CATEGORY_NAME));
        RecurringTransactionRequestDto dto = new RecurringTransactionRequestDto(new BigDecimal(AMOUNT), DESCRIPTION,
                category.getId(), INTERVAL_DAYS);
        mockMvc.perform(post(API_RECURRING_TRANSACTION_CREATE)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.message").value(msg("handle.user.not.found.by.id")))
                .andExpect(jsonPath("$.path").value(API_RECURRING_TRANSACTION_CREATE));
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void create_shouldReturnBadRequest_whenCategoryNotExists() throws Exception {
        RecurringTransactionRequestDto dto = new RecurringTransactionRequestDto(new BigDecimal(AMOUNT), DESCRIPTION,
                ID_INVALID, INTERVAL_DAYS);
        mockMvc.perform(post(API_RECURRING_TRANSACTION_CREATE)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(msg("handle.illegal.argument")))
                .andExpect(jsonPath("$.path").value(API_RECURRING_TRANSACTION_CREATE));
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void create_shouldReturnBadRequest_whenAmountIsNegative() throws Exception {
        Category category = categoryRepository.save(new Category(CATEGORY_NAME));
        RecurringTransactionRequestDto dto = new RecurringTransactionRequestDto(new BigDecimal(AMOUNT_NEGATIVE), 
                DESCRIPTION, category.getId(), INTERVAL_DAYS);
        mockMvc.perform(post(API_RECURRING_TRANSACTION_CREATE)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(msg("recurring.transaction.request.amount.positive")))
                .andExpect(jsonPath("$.path").value(API_RECURRING_TRANSACTION_CREATE));
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void create_shouldReturnBadRequest_whenDescriptionIsNull() throws Exception {
        Category category = categoryRepository.save(new Category(CATEGORY_NAME));
        RecurringTransactionRequestDto dto = new RecurringTransactionRequestDto(new BigDecimal(AMOUNT), null,
                category.getId(), INTERVAL_DAYS);
        mockMvc.perform(post(API_RECURRING_TRANSACTION_CREATE)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(msg("recurring.transaction.request.description.not.blank")))
                .andExpect(jsonPath("$.path").value(API_RECURRING_TRANSACTION_CREATE));
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void create_shouldReturnBadRequest_whenDescriptionIsEmpty() throws Exception {
        Category category = categoryRepository.save(new Category(CATEGORY_NAME));
        RecurringTransactionRequestDto dto = new RecurringTransactionRequestDto(new BigDecimal(AMOUNT),
                "", category.getId(), INTERVAL_DAYS);
        mockMvc.perform(post(API_RECURRING_TRANSACTION_CREATE)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(msg("recurring.transaction.request.description.not.blank")))
                .andExpect(jsonPath("$.path").value(API_RECURRING_TRANSACTION_CREATE));
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void create_shouldReturnBadRequest_whenCategoryIdIsNull() throws Exception {
        RecurringTransactionRequestDto dto = new RecurringTransactionRequestDto(new BigDecimal(AMOUNT),
                DESCRIPTION, null, INTERVAL_DAYS);
        mockMvc.perform(post(API_RECURRING_TRANSACTION_CREATE)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(msg("recurring.transaction.request.category.id.not.null")))
                .andExpect(jsonPath("$.path").value(API_RECURRING_TRANSACTION_CREATE));
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void create_shouldReturnBadRequest_whenIntervalDaysLessThanOne() throws Exception {
        Category category = categoryRepository.save(new Category(CATEGORY_NAME));
        RecurringTransactionRequestDto dto = new RecurringTransactionRequestDto(new BigDecimal(AMOUNT),
                DESCRIPTION, category.getId(), 0);
        mockMvc.perform(post(API_RECURRING_TRANSACTION_CREATE)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(containsString("1")))
                .andExpect(jsonPath("$.path").value(API_RECURRING_TRANSACTION_CREATE));
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void toggleActive_shouldSwitchActive_whenIdValid() throws Exception {
        Category category = categoryRepository.save(new Category(CATEGORY_NAME));
        RecurringTransaction recurringTransaction = new RecurringTransaction(new BigDecimal(AMOUNT), DESCRIPTION,
                category, user, INTERVAL_DAYS, LocalDate.now().minusDays(1));
        RecurringTransaction saved = recurringTransactionRepository.save(recurringTransaction);
        mockMvc.perform(patch(API_RECURRING_TRANSACTION + "/" + saved.getId() + "/toggle"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("recurring.transaction.controller.toggle.active")))
                .andExpect(jsonPath("$.path").value(API_RECURRING_TRANSACTION +
                        "/" + saved.getId() + "/toggle"));
        assertThat(recurringTransactionRepository.findById(saved.getId()).orElseThrow().isActive()).isFalse();
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void toggleActive_shouldSwitchBackToActive_whenPreviouslyInactive() throws Exception {
        Category category = categoryRepository.save(new Category(CATEGORY_NAME));
        RecurringTransaction recurringTransaction = new RecurringTransaction(new BigDecimal(AMOUNT), DESCRIPTION,
                category, user, INTERVAL_DAYS, LocalDate.now().minusDays(1));
        recurringTransaction.setActive(false);
        RecurringTransaction saved = recurringTransactionRepository.save(recurringTransaction);
        mockMvc.perform(patch(API_RECURRING_TRANSACTION + "/" + saved.getId() + "/toggle"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("recurring.transaction.controller.toggle.active")))
                .andExpect(jsonPath("$.path").value(API_RECURRING_TRANSACTION +
                        "/" + saved.getId() + "/toggle"));
        assertThat(recurringTransactionRepository.findById(saved.getId()).orElseThrow().isActive()).isTrue();
    }

    @Test
    @WithUserDetails(value = USER_EMAIL, userDetailsServiceBeanName = "customUserDetailsService",
            setupBefore = TestExecutionEvent.TEST_EXECUTION)
    void toggleActive_shouldReturnBadRequest_whenIdInvalid() throws Exception {
        mockMvc.perform(patch(API_RECURRING_TRANSACTION + "/" + ID_INVALID + "/toggle"))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(msg("handle.illegal.argument")))
                .andExpect(jsonPath("$.path").value(API_RECURRING_TRANSACTION +
                        "/" + ID_INVALID + "/toggle"));
    }
}

package test.controller;

import com.example.expensetracker.ExpenseTrackerApplication;
import com.example.expensetracker.dto.ChangePasswordRequest;
import com.example.expensetracker.model.Role;
import com.example.expensetracker.model.User;
import com.example.expensetracker.repository.UserRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import test.security.WithMockCustomUser;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static test.util.Constants.*;
import static test.util.TestUtils.createAndSaveUser;

@SpringBootTest(classes = {ExpenseTrackerApplication.class},
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
@AutoConfigureMockMvc
public class UserControllerIT {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private MessageSource messageSource;

    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Autowired
    private PasswordEncoder passwordEncoder;

    @Test
    @WithMockCustomUser(email = USER_EMAIL, roles = {"USER"})
    void getCurrentUser_shouldReturnAuthenticatedUser_whenUserLoggedIn() throws Exception {
        createAndSaveUser(USER_EMAIL, Role.USER, userRepository);
        performMe(USER_EMAIL);
    }

    @Test
    @WithMockCustomUser(email = MODERATOR_EMAIL, roles = {"MODERATOR"})
    void getCurrentUser_shouldReturnAuthenticatedModerator_whenModeratorLoggedIn() throws Exception {
        createAndSaveUser(MODERATOR_EMAIL, Role.MODERATOR, userRepository);
        performMe(MODERATOR_EMAIL);
    }

    @Test
    @WithMockCustomUser(email = ADMIN_EMAIL, roles = {"ADMIN"})
    void getCurrentUser_shouldReturnAuthenticatedAdmin_whenAdminLoggedIn() throws Exception {
        createAndSaveUser(ADMIN_EMAIL, Role.ADMIN, userRepository);
        performMe(ADMIN_EMAIL);
    }

    @Test
    void getCurrentUser_shouldReturnUnauthorized_whenNoUserLoggedIn() throws Exception {
        mockMvc.perform(get(API_USERS_ME))
                .andExpect(status().isUnauthorized());
    }

    @Test
    @WithMockCustomUser(email = USER_EMAIL, roles = {"USER"})
    void getCurrentUser_shouldReturnAuthenticatedAdmin_whenUserNotFound() throws Exception {
        userRepository.deleteAll();
        mockMvc.perform(get(API_USERS_ME))
                .andExpect(status().isUnauthorized()) 
                .andExpect(jsonPath("$.message").value(msg("handle.username.not.found")));
    }

    @Test
    @WithMockCustomUser(email = USER_EMAIL, roles = {"USER"})
    void changePassword_shouldReturnOk_whenAllFieldsValid() throws Exception {
        User user = createAndSaveUser(USER_EMAIL, Role.USER, userRepository);
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        userRepository.save(user);
        ChangePasswordRequest req = new ChangePasswordRequest(USER_PASSWORD, "newPass");
        mockMvc.perform(put(API_USERS_CHANGE_PASSWORD)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(req)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("user.controller.password.changed.success")));
    }

    @Test
    @WithMockCustomUser(email = USER_EMAIL, roles = {"USER"})
    void changePassword_shouldThrowException_whenPasswordNotMatches() throws Exception {
        User user = createAndSaveUser(USER_EMAIL, Role.USER, userRepository);
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        userRepository.save(user);
        ChangePasswordRequest req = new ChangePasswordRequest("invalidPassword", "newPass");
        mockMvc.perform(put(API_USERS_CHANGE_PASSWORD)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(req)))
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.message").value(msg("handle.bad.credentials")));
    }

    @Test
    @WithMockCustomUser(email = USER_EMAIL, roles = {"USER"})
    void changePassword_shouldThrowException_whenOldPasswordEmpty() throws Exception {
        createAndSaveUser(USER_EMAIL, Role.USER, userRepository);
        ChangePasswordRequest req = new ChangePasswordRequest("", "newPass");
        mockMvc.perform(put(API_USERS_CHANGE_PASSWORD)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(req)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(msg("user.controller.user.password.old.not-blank")));
    }

    @Test
    @WithMockCustomUser(email = USER_EMAIL, roles = {"USER"})
    void changePassword_shouldThrowException_whenNewPasswordEmpty() throws Exception {
        User user = createAndSaveUser(USER_EMAIL, Role.USER, userRepository);
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        userRepository.save(user);
        ChangePasswordRequest req = new ChangePasswordRequest(USER_PASSWORD, "");
        mockMvc.perform(put(API_USERS_CHANGE_PASSWORD)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(req)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(msg("user.controller.user.password.new.not-blank")));
    }

    @Test
    @WithMockCustomUser(email = USER_EMAIL, roles = {"USER"})
    void changePassword_shouldThrowException_whenUserNotFound() throws Exception {
        ChangePasswordRequest req = new ChangePasswordRequest(USER_PASSWORD, USER_PASSWORD_NEW);
        mockMvc.perform(put(API_USERS_CHANGE_PASSWORD)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(req)))
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.message").value(msg("handle.username.not.found")));
    }

    private String msg(String code) {
        return messageSource.getMessage(code, null, LocaleContextHolder.getLocale());
    }

    private void performMe(String email) throws Exception {
        mockMvc.perform(get(API_USERS_ME))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value(msg("user.controller.get.current.user")))
                .andExpect(jsonPath("$.path").value(API_USERS_ME))
                .andExpect(jsonPath("$.data.email").value(email));
    }
}

package test.details;

import com.example.expensetracker.details.UserDetailsImpl;
import com.example.expensetracker.model.Role;
import com.example.expensetracker.model.User;
import org.junit.jupiter.api.Test;
import org.springframework.security.core.GrantedAuthority;
import test.util.TestData;

import java.util.Collection;

import static org.assertj.core.api.Assertions.assertThat;
import static test.util.Constants.USER_PASSWORD;
import static test.util.Constants.USER_EMAIL;

public class UserDetailsImplTest {
    
    @Test
    void getAuthorities_shouldReturnCorrectAuthorities() {
        UserDetailsImpl userDetails = new UserDetailsImpl(TestData.moderator());

        Collection<? extends GrantedAuthority> authorities = userDetails.getAuthorities();
        
        assertThat(authorities).extracting(GrantedAuthority::getAuthority).containsExactlyInAnyOrder(
                "ROLE_USER", "ROLE_MODERATOR");
    }

    @Test
    void getAuthorities_shouldReturnEmptyAuthorities_whenRoleIsNull() {
        UserDetailsImpl userDetails = new UserDetailsImpl(new User());

        Collection<? extends GrantedAuthority> authorities = userDetails.getAuthorities();

        assertThat(authorities).isEmpty();
    }
    
    @Test
    void shouldReturnCorrectUsername() {
        UserDetailsImpl userDetails = new UserDetailsImpl(TestData.user());
        
        assertThat(userDetails).isNotNull();
        assertThat(userDetails.getUsername()).isEqualTo(USER_EMAIL);
    }

    @Test
    void shouldReturnCorrectPassword() {
        UserDetailsImpl userDetails = new UserDetailsImpl(TestData.user());

        assertThat(userDetails).isNotNull();
        assertThat(userDetails.getPassword()).isEqualTo(USER_PASSWORD);
    }

    @Test
    void shouldReturnTrueForAllSecurityFlags() {
        UserDetailsImpl userDetails = new UserDetailsImpl(TestData.user());
        
        assertThat(userDetails).isNotNull();
        assertThat(userDetails.isAccountNonExpired()).isEqualTo(true);
        assertThat(userDetails.isAccountNonLocked()).isEqualTo(true);
        assertThat(userDetails.isCredentialsNonExpired()).isEqualTo(true);
        assertThat(userDetails.isEnabled()).isEqualTo(true);
    }

    @Test
    void shouldReturnFalse_whenUserIsBlocked() {
        UserDetailsImpl userDetails = new UserDetailsImpl(TestData.userBanned());

        assertThat(userDetails).isNotNull();
        assertThat(userDetails.isAccountNonLocked()).isEqualTo(false);
        assertThat(userDetails.isEnabled()).isEqualTo(false);
    }
    
    @Test
    void shouldReturnCorrectId() {
        User user = TestData.user();
        
        UserDetailsImpl userDetails = new UserDetailsImpl(user);
        
        assertThat(userDetails).isNotNull();
        assertThat(userDetails.getDomainUser().getId()).isEqualTo(user.getId());
    }
    
    @Test
    void shouldReturnCorrectUser() {
        User user = TestData.user();

        UserDetailsImpl userDetails = new UserDetailsImpl(user);

        assertThat(userDetails).isNotNull();
        assertThat(userDetails.getDomainUser()).isSameAs(user);
    }

    @Test
    void shouldReturnCorrectName() {
        UserDetailsImpl userDetails = new UserDetailsImpl(TestData.user());

        assertThat(userDetails).isNotNull();
        assertThat(userDetails.getName()).isEqualTo(USER_EMAIL);
    }
}

package test.dto;

import com.example.expensetracker.dto.ApiResponse;
import jakarta.servlet.http.HttpServletRequest;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.HttpStatus;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.Objects;

import static com.example.expensetracker.dto.ApiResponseFactory.*;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.within;
import static org.mockito.Mockito.when;
import static test.util.Constants.API_TEST_ENDPOINT;

@ExtendWith(MockitoExtension.class)
public class ApiResponseFactoryTest {

    @Mock
    HttpServletRequest request;

    private final String path = API_TEST_ENDPOINT;

    @Test
    void success_shouldReturn200() {
        String data = "ok";
        String message = "—É—Å–ø–µ—Ö";
        when(request.getRequestURI()).thenReturn(API_TEST_ENDPOINT);

        var result = success(data, message, request);

        assertThat(result.getTimestamp()).isCloseTo(Instant.now(), within(1, ChronoUnit.SECONDS));
        assertThat(result.getStatus()).isEqualTo(HttpStatus.OK.value());
        assertThat(result.getMessage()).isEqualTo(message);
        assertThat(result.getPath()).isEqualTo(path);
        assertThat(result.getData()).isEqualTo(data);
    }

    @Test
    void error_shouldReturn500() {
        HttpStatus status = HttpStatus.INTERNAL_SERVER_ERROR;
        String error = "500";
        String message = "–æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞";
        when(request.getRequestURI()).thenReturn(API_TEST_ENDPOINT);

        var result = error(status, error, message, request);

        assertThat(result.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
        var body = result.getBody();
        assertThat(body).isNotNull();
        assertThat(body.getTimestamp()).isCloseTo(Instant.now(), within(1, ChronoUnit.SECONDS));
        assertThat(body.getStatus()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR.value());
        assertThat(body.getError()).isEqualTo(error);
        assertThat(body.getMessage()).isEqualTo(message);
        assertThat(body.getPath()).isEqualTo(path);
    }

    @Test
    void validationError_shouldReturn400() {
        HttpStatus status = HttpStatus.BAD_REQUEST;
        String message = "–æ—à–∏–±–∫–∞ –∫–ª–∏–µ–Ω—Ç–∞";
        List<String> errors = List.of("Exception");
        when(request.getRequestURI()).thenReturn(API_TEST_ENDPOINT);

        var result = validationError(status, message, request, errors);

        assertThat(result.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
        ApiResponse<?> body = result.getBody();
        assertThat(body).isNotNull();
        Objects.requireNonNull(body);
        assertThat(body.getTimestamp()).isCloseTo(Instant.now(), within(1, ChronoUnit.SECONDS));
        assertThat(body.getStatus()).isEqualTo(HttpStatus.BAD_REQUEST.value());
        assertThat(body.getError()).isEqualTo("ValidationError");
        assertThat(body.getMessage()).isEqualTo(message);
        assertThat(body.getPath()).isEqualTo(path);
        List<String> er = body.getErrors();
        assertThat(er).containsExactly("Exception");
    }

    @Test
    void unauthorized_shouldReturnResponse401() {
        when(request.getRequestURI()).thenReturn(API_TEST_ENDPOINT);

        var result = unauthorized(request);

        assertThat(result.getTimestamp()).isCloseTo(Instant.now(), within(1, ChronoUnit.SECONDS));
        assertThat(result.getStatus()).isEqualTo(HttpStatus.UNAUTHORIZED.value());
        assertThat(result.getError()).isEqualTo(HttpStatus.UNAUTHORIZED.getReasonPhrase());
        assertThat(result.getMessage()).isEqualTo("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω: —Ç—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è");
        assertThat(result.getPath()).isEqualTo(path);
    }

    @Test
    void forbidden_shouldReturnResponse403() {
        when(request.getRequestURI()).thenReturn(API_TEST_ENDPOINT);

        var result = forbidden(request);

        assertThat(result.getTimestamp()).isCloseTo(Instant.now(), within(1, ChronoUnit.SECONDS));
        assertThat(result.getStatus()).isEqualTo(HttpStatus.FORBIDDEN.value());
        assertThat(result.getError()).isEqualTo(HttpStatus.FORBIDDEN.getReasonPhrase());
        assertThat(result.getMessage()).isEqualTo("–£ –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É —Ä–µ—Å—É—Ä—Å—É");
        assertThat(result.getPath()).isEqualTo(path);
    }
}


package test.dto;

import com.example.expensetracker.dto.AuthResponse;
import com.example.expensetracker.model.Role;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;
import static test.util.Constants.USER_EMAIL;

public class AuthResponseTest {

    @Test
    void shouldPass_whenAllFieldsValid() {
        AuthResponse auth = new AuthResponse("token", USER_EMAIL, Role.USER.name());

        assertThat(auth.getToken()).isEqualTo("token");
        assertThat(auth.getEmail()).isEqualTo(USER_EMAIL);
        assertThat(auth.getRole()).isEqualTo(Role.USER.name());
    }
}

package test.dto;

import com.example.expensetracker.dto.ChangePasswordRequest;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.ValidatorFactory;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import test.util.TestUtils;

import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;
import static test.util.Constants.USER_PASSWORD;
import static test.util.Constants.USER_PASSWORD_NEW;
import static test.util.TestMessageSource.msg;

public class ChangePasswordRequestTest {

    private static Validator validator;

    @BeforeAll
    static void setUpValidator() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    void shouldPass_whenAllFieldsValid() {
        ChangePasswordRequest request = new ChangePasswordRequest(USER_PASSWORD, USER_PASSWORD_NEW);
        Set<ConstraintViolation<ChangePasswordRequest>> violations = validator.validate(request);

        assertThat(violations).isEmpty();
    }

    @Test
    void shouldFail_whenPasswordIsNull() {
        ChangePasswordRequest request = new ChangePasswordRequest(null, USER_PASSWORD_NEW);
        Set<ConstraintViolation<ChangePasswordRequest>> violations = validator.validate(request);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "oldPassword", msg("user.controller.user.password.old.not-blank"));
    }

    @Test
    void shouldFail_whenPasswordIsEmpty() {
        ChangePasswordRequest request = new ChangePasswordRequest("", USER_PASSWORD_NEW);
        Set<ConstraintViolation<ChangePasswordRequest>> violations = validator.validate(request);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "oldPassword", msg("user.controller.user.password.old.not-blank"));
    }

    @Test
    void shouldFail_whenNewPasswordIsNull() {
        ChangePasswordRequest request = new ChangePasswordRequest(USER_PASSWORD, null);
        Set<ConstraintViolation<ChangePasswordRequest>> violations = validator.validate(request);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "newPassword", msg("user.controller.user.password.new.not-blank"));
    }

    @Test
    void shouldFail_whenNewPasswordIsEmpty() {
        ChangePasswordRequest request = new ChangePasswordRequest(USER_PASSWORD, "");
        Set<ConstraintViolation<ChangePasswordRequest>> violations = validator.validate(request);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "newPassword", msg("user.controller.user.password.new.not-blank"));
    }
}

package test.dto;

import com.example.expensetracker.dto.DateRangeDto;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.ValidatorFactory;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import test.util.TestUtils;

import java.time.Instant;
import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;
import static test.util.TestMessageSource.msg;

public class DateRangeDtoTest {
    private static Validator validator;

    @BeforeAll
    static void setUpValidator() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }
    
    @Test
    void shouldPass_whenAllFieldsValid() {
        DateRangeDto dto = getDateRangeDto(1000, 2000);

        Set<ConstraintViolation<DateRangeDto>> violations = validator.validate(dto);

        assertThat(violations).isEmpty();
    }

    @Test
    void shouldFail_whenFromAfterTo() {
        DateRangeDto dto = getDateRangeDto(3000, 2000);
        
        Set<ConstraintViolation<DateRangeDto>> violations = validator.validate(dto);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "validRange", msg("date.range.dto.from.is.valid.range"));
    }

    @Test
    void shouldFail_whenFromIsNull() {
        DateRangeDto dto = getDateRangeDto(null, 2000);
        
        Set<ConstraintViolation<DateRangeDto>> violations = validator.validate(dto);

        assertThat(violations).hasSize(2);
        TestUtils.assertHasViolation(violations, "from", msg("date.range.dto.from.not.null"));
        TestUtils.assertHasViolation(violations, "validRange", msg("date.range.dto.from.is.valid.range"));
    }

    @Test
    void shouldFail_whenToIsNull() {
        DateRangeDto dto = getDateRangeDto(1000, null);
        
        Set<ConstraintViolation<DateRangeDto>> violations = validator.validate(dto);

        assertThat(violations).hasSize(2);
        TestUtils.assertHasViolation(violations, "to", msg("date.range.dto.to.not.null"));
        TestUtils.assertHasViolation(violations, "validRange", msg("date.range.dto.from.is.valid.range"));
    }

    @Test
    void isValidRange_shouldReturnTrue_whenAllFieldsValid() {
        DateRangeDto dto = getDateRangeDto(1000, 2000);

        boolean result = dto.isValidRange();

        assertThat(result).isTrue();
    }

    private static DateRangeDto getDateRangeDto(Integer from, Integer to) {
        DateRangeDto dto = new DateRangeDto();
        if (from != null) dto.setFrom(Instant.ofEpochSecond(from));
        if (to != null) dto.setTo(Instant.ofEpochSecond(to));
        return dto;
    }
}

package test.dto;

import com.example.expensetracker.dto.LoginDto;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.ValidatorFactory;
import nl.jqno.equalsverifier.EqualsVerifier;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import test.util.TestData;
import test.util.TestUtils;

import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;
import static test.util.Constants.*;

public class LoginDtoTest {

    private static Validator validator;

    @BeforeAll
    static void setUpValidator() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    void shouldPass_whenAllFieldsValid() {
        LoginDto loginDto = new LoginDto(USER_EMAIL, USER_PASSWORD);
        Set<ConstraintViolation<LoginDto>> violations = validator.validate(loginDto);

        assertThat(violations).isEmpty();
    }

    @Test
    void shouldFail_whenEmailInvalid() {
        LoginDto registerDto = new LoginDto("not-email", USER_PASSWORD);
        Set<ConstraintViolation<LoginDto>> violations = validator.validate(registerDto);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "email", "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –ø–æ—á—Ç–∞");
    }

    @Test
    void shouldFail_whenEmailIsNull() {
        LoginDto loginDto = new LoginDto(null, USER_PASSWORD);
        Set<ConstraintViolation<LoginDto>> violations = validator.validate(loginDto);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "email", "–ü–æ—á—Ç–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞");
    }

    @Test
    void shouldFail_whenEmailIsEmpty() {
        LoginDto loginDto = new LoginDto("", USER_PASSWORD);
        Set<ConstraintViolation<LoginDto>> violations = validator.validate(loginDto);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "email", "–ü–æ—á—Ç–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞");
    }

    @Test
    void shouldFail_whenPasswordIsNull() {
        LoginDto loginDto = new LoginDto(USER_EMAIL, null);
        Set<ConstraintViolation<LoginDto>> violations = validator.validate(loginDto);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "password", "–ü–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω");
    }

    @Test
    void shouldFail_whenPasswordIsEmpty() {
        LoginDto loginDto = new LoginDto(USER_EMAIL, "");
        Set<ConstraintViolation<LoginDto>> violations = validator.validate(loginDto);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "password", "–ü–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω");
    }
    
    @Test
    void constructor_shouldSetAllFieldsCorrectly() {
        LoginDto loginDto = new LoginDto(USER_EMAIL, USER_PASSWORD);
        
        assertThat(loginDto.getEmail()).isEqualTo(USER_EMAIL);
        assertThat(loginDto.getPassword()).isEqualTo(USER_PASSWORD);
    }

    @Test
    void equalsHashCode_contract() {
        EqualsVerifier.forClass(LoginDto.class)
                .withOnlyTheseFields("email", "password")
                .usingGetClass()
                .verify();
    }

    @Test
    void toStringTest() {
        LoginDto dto = TestData.loginDto();
        assertThat(dto).asString().contains(USER_EMAIL).contains("****");
    }
}

package test.dto;

import com.example.expensetracker.dto.RecurringTransactionDto;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.time.LocalDate;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static test.util.Constants.*;

public class RecurringTransactionDtoTest {

    @Test
    void shouldSetFieldsUsingConstructor() throws Exception {
        BigDecimal amount = new BigDecimal(AMOUNT);
        LocalDate now = LocalDate.now();
        RecurringTransactionDto result = new RecurringTransactionDto(ID_TRANSACTION, amount,
                DESCRIPTION, ID_CATEGORY, CATEGORY_NAME, INTERVAL_DAYS, now, true);

        assertThat(result).extracting(
                RecurringTransactionDto::getId,
                RecurringTransactionDto::getAmount,
                RecurringTransactionDto::getDescription,
                RecurringTransactionDto::getCategoryId,
                RecurringTransactionDto::getCategoryName,
                RecurringTransactionDto::getIntervalDays,
                RecurringTransactionDto::getNextExecutionDate)
                .containsExactly(
                        ID_TRANSACTION,
                        amount,
                        DESCRIPTION,
                        ID_CATEGORY,
                        CATEGORY_NAME,
                        INTERVAL_DAYS,
                        now
                );
        assertThat(result.isActive()).isTrue();
    }

    @Test
    void constructor_shouldThrowException_whenAmountIsNull() throws Exception {
        var ex = checkEx(null, DESCRIPTION, ID_CATEGORY, LocalDate.now());
        
        assertThat(ex.getMessage()).isEqualTo("RecurringTransactionDto: mandatory field is null");
    }

    @Test
    void constructor_shouldThrowException_whenDescriptionIsNull() throws Exception {
        var ex = checkEx(new BigDecimal(AMOUNT), null, ID_CATEGORY, LocalDate.now());

        assertThat(ex.getMessage()).isEqualTo("RecurringTransactionDto: mandatory field is null");
    }

    @Test
    void constructor_shouldThrowException_whenCategoryIdIsNull() throws Exception {
        var ex = checkEx(new BigDecimal(AMOUNT), DESCRIPTION, null, LocalDate.now());

        assertThat(ex.getMessage()).isEqualTo("RecurringTransactionDto: mandatory field is null");
    }

    @Test
    void constructor_shouldThrowException_whenNextExecutionDateIsNull() throws Exception {
        var ex = checkEx(new BigDecimal(AMOUNT), DESCRIPTION, ID_CATEGORY, null);

        assertThat(ex.getMessage()).isEqualTo("RecurringTransactionDto: mandatory field is null");
    }
    
    private IllegalArgumentException checkEx(BigDecimal amount, String description, 
                                             Long categoryId, LocalDate nextExecutionDate) {
        return assertThrows(IllegalArgumentException.class,
                () -> new RecurringTransactionDto(ID_TRANSACTION, amount,
                        description, categoryId, CATEGORY_NAME, INTERVAL_DAYS, nextExecutionDate, true));
    } 
}

package test.dto;

import com.example.expensetracker.dto.RecurringTransactionRequestDto;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.ValidatorFactory;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import test.util.TestUtils;

import java.math.BigDecimal;
import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;
import static test.util.Constants.*;
import static test.util.TestMessageSource.msg;

public class RecurringTransactionRequestDtoTest {

    private static Validator validator;

    @BeforeAll
    static void setUpValidator() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    void shouldPass_whenAllFieldsValid() {
        RecurringTransactionRequestDto request = new RecurringTransactionRequestDto(new BigDecimal(AMOUNT), 
                DESCRIPTION, ID_CATEGORY, INTERVAL_DAYS);
        Set<ConstraintViolation<RecurringTransactionRequestDto>> violations = validator.validate(request);

        assertThat(violations).isEmpty();
    }

    @Test
    void shouldFail_whenAmountIsNull() {
        RecurringTransactionRequestDto request = new RecurringTransactionRequestDto(null,
                DESCRIPTION, ID_CATEGORY, INTERVAL_DAYS);
        Set<ConstraintViolation<RecurringTransactionRequestDto>> violations = validator.validate(request);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "amount", msg("recurring.transaction.request.amount.not.null"));
    }

    @Test
    void shouldFail_whenAmountIsNegative() {
        RecurringTransactionRequestDto request = new RecurringTransactionRequestDto(new BigDecimal(AMOUNT_NEGATIVE),
                DESCRIPTION, ID_CATEGORY, INTERVAL_DAYS);
        Set<ConstraintViolation<RecurringTransactionRequestDto>> violations = validator.validate(request);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "amount", msg("recurring.transaction.request.amount.positive"));
    }

    @Test
    void shouldFail_whenDescriptionIsNull() {
        RecurringTransactionRequestDto request = new RecurringTransactionRequestDto(new BigDecimal(AMOUNT),
                null, ID_CATEGORY, INTERVAL_DAYS);
        Set<ConstraintViolation<RecurringTransactionRequestDto>> violations = validator.validate(request);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "description", msg("recurring.transaction.request.description.not.blank"));
    }

    @Test
    void shouldFail_whenDescriptionIsEmpty() {
        RecurringTransactionRequestDto request = new RecurringTransactionRequestDto(new BigDecimal(AMOUNT),
                "", ID_CATEGORY, INTERVAL_DAYS);
        Set<ConstraintViolation<RecurringTransactionRequestDto>> violations = validator.validate(request);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "description", msg("recurring.transaction.request.description.not.blank"));
    }

    @Test
    void shouldFail_whenCategoryIdIsNull() {
        RecurringTransactionRequestDto request = new RecurringTransactionRequestDto(new BigDecimal(AMOUNT),
                DESCRIPTION, null, INTERVAL_DAYS);
        Set<ConstraintViolation<RecurringTransactionRequestDto>> violations = validator.validate(request);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "categoryId", msg("recurring.transaction.request.category.id.not.null"));
    }

    @Test
    void shouldFail_whenIntervalDaysIsZero() {
        RecurringTransactionRequestDto request = new RecurringTransactionRequestDto(new BigDecimal(AMOUNT),
                DESCRIPTION, ID_CATEGORY, 0);
        Set<ConstraintViolation<RecurringTransactionRequestDto>> violations = validator.validate(request);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "intervalDays", "–¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–µ –º–µ–Ω—å—à–µ 1");
    }
}

package test.dto;

import com.example.expensetracker.dto.RegisterDto;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.ValidatorFactory;
import nl.jqno.equalsverifier.EqualsVerifier;
import nl.jqno.equalsverifier.Warning;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import test.util.TestData;
import test.util.TestUtils;

import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;
import static test.util.Constants.*;
import static test.util.TestMessageSource.msg;

public class RegisterDtoTest {

    private static Validator validator;

    @BeforeAll
    static void setUpValidator() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    void shouldPass_whenAllFieldsValid() {
        RegisterDto registerDto = new RegisterDto(USER_NAME, USER_EMAIL, USER_PASSWORD);
        Set<ConstraintViolation<RegisterDto>> violations = validator.validate(registerDto);

        assertThat(violations).isEmpty();
        assertThat(registerDto.getName()).isEqualTo(USER_NAME);
        assertThat(registerDto.getEmail()).isEqualTo(USER_EMAIL);
        assertThat(registerDto.getPassword()).isEqualTo(USER_PASSWORD);
    }

    @Test
    void shouldFail_whenNameIsNull() {
        RegisterDto registerDto = new RegisterDto(null, USER_EMAIL, USER_PASSWORD);
        Set<ConstraintViolation<RegisterDto>> violations = validator.validate(registerDto);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "name", msg("user.name.not-blank"));
    }

    @Test
    void shouldFail_whenNameIsEmpty() {
        RegisterDto registerDto = new RegisterDto("", USER_EMAIL, USER_PASSWORD);
        Set<ConstraintViolation<RegisterDto>> violations = validator.validate(registerDto);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "name",
                "–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º");
    }

    @Test
    void shouldFail_whenEmailInvalid() {
        RegisterDto registerDto = new RegisterDto(USER_NAME, "not-email", USER_PASSWORD);
        Set<ConstraintViolation<RegisterDto>> violations = validator.validate(registerDto);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "email", "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –ø–æ—á—Ç–∞");
    }

    @Test
    void shouldFail_whenEmailIsNull() {
        RegisterDto registerDto = new RegisterDto(USER_NAME, null, USER_PASSWORD);
        Set<ConstraintViolation<RegisterDto>> violations = validator.validate(registerDto);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "email", "–ü–æ—á—Ç–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞");
    }

    @Test
    void shouldFail_whenEmailIsEmpty() {
        RegisterDto registerDto = new RegisterDto(USER_NAME, "", USER_PASSWORD);
        Set<ConstraintViolation<RegisterDto>> violations = validator.validate(registerDto);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "email", "–ü–æ—á—Ç–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞");
    }

    @Test
    void shouldFail_whenPasswordIsNull() {
        RegisterDto registerDto = new RegisterDto(USER_NAME, USER_EMAIL, null);
        Set<ConstraintViolation<RegisterDto>> violations = validator.validate(registerDto);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "password", "–ü–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω");
    }

    @Test
    void shouldFail_whenPasswordIsEmpty() {
        RegisterDto registerDto = new RegisterDto(USER_NAME, USER_EMAIL, "");
        Set<ConstraintViolation<RegisterDto>> violations = validator.validate(registerDto);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "password", "–ü–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω");
    }

    @Test
    void equalsHashCode_contract() {
        EqualsVerifier.forClass(RegisterDto.class)
                .withOnlyTheseFields("name", "email", "password")
                .suppress(Warning.NONFINAL_FIELDS)
                .usingGetClass()
                .verify();
    }

    @Test
    void toStringTest() {
        RegisterDto dto = TestData.registerDto();
        assertThat(dto).asString().contains(USER_NAME).contains(USER_EMAIL).contains("****");
    }
}

package test.dto;

import com.example.expensetracker.dto.UserDto;
import com.example.expensetracker.model.User;
import org.junit.jupiter.api.Test;
import test.util.TestData;

import java.util.List;

import static com.example.expensetracker.dto.UserDto.fromEntities;
import static com.example.expensetracker.dto.UserDto.fromEntity;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.AssertionsForClassTypes.tuple;
import static test.util.Constants.*;

public class UserDtoTest {
    
    @Test
    void constructor_shouldReturnCorrectValue() {
        UserDto userDto = new UserDto(ID_VALID, USER_EMAIL);
        
        assertThat(userDto.getId()).isEqualTo(ID_VALID);
        assertThat(userDto.getEmail()).isEqualTo(USER_EMAIL);
    }

    @Test
    void fromEntity_shouldMapAllFieldsCorrectly() {
        User user = TestData.user();
        
        UserDto userDto = fromEntity(user);

        assertThat(userDto).extracting(UserDto::getId, UserDto::getEmail).containsExactly(ID_VALID, USER_EMAIL);
    }

    @Test
    void fromEntities_shouldMapListCorrectly() {
        User user = TestData.user();
        User admin = TestData.user();
        List<UserDto> userDto = fromEntities(List.of(user, admin));

        assertThat(userDto)
                .hasSize(2)
                .extracting(UserDto::getId, UserDto::getEmail)
                .containsExactly(tuple(user.getId(), user.getEmail()), tuple(admin.getId(), admin.getEmail()));
    }
}

package test.exception;

import com.example.expensetracker.dto.ApiResponse;
import com.example.expensetracker.exception.GlobalExceptionHandler;
import com.example.expensetracker.exception.UserNotFoundByIdException;
import com.example.expensetracker.logging.applog.AppLogDto;
import com.example.expensetracker.logging.applog.AppLogService;
import jakarta.persistence.EntityExistsException;
import jakarta.persistence.EntityNotFoundException;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.ConstraintViolationException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.context.MessageSource;
import org.springframework.core.MethodParameter;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.validation.method.MethodValidationResult;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.method.annotation.HandlerMethodValidationException;

import java.util.List;
import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.*;
import static test.util.Constants.API_TEST_ENDPOINT;

@ExtendWith(MockitoExtension.class)
public class GlobalExceptionHandlerTest {

    @Mock
    private MessageSource messageSource;

    @Mock
    private AppLogService appLogService;

    @InjectMocks
    private GlobalExceptionHandler handler;

    private MockHttpServletRequest request;

    @BeforeEach
    void setUp() {
        request = new MockHttpServletRequest();
        request.setRequestURI(API_TEST_ENDPOINT);
    }

    @Test
    void handleBadCredentials_shouldReturnUnauthorizedResponse() {
        mockMessage();
        BadCredentialsException ex = new BadCredentialsException("");

        var response = handler.handleBadCredentials(ex, request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
        checkBody(response.getBody(), 401, "handle.bad.credentials");
        verify(appLogService).log(any());
    }

    @Test
    void handleBadCredentials_shouldUsePrincipalNameWhenPresent() {
        mockMessage();
        request.setUserPrincipal(() -> "test-user");
        BadCredentialsException ex = new BadCredentialsException("");

        var response = handler.handleBadCredentials(ex, request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
        verify(appLogService).log(any());
    }

    @Test
    void handleAccessDenied_shouldReturnForbiddenResponse() {
        mockMessage();
        AccessDeniedException ex = new AccessDeniedException("");

        var response = handler.handleAccessDenied(ex, request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
        checkBody(response.getBody(), 403, "handle.access.denied");
        verify(appLogService).log(any());
    }

    @Test
    void handleEntityNotFound_shouldReturnNotFoundResponse() {
        mockMessage();
        EntityNotFoundException ex = new EntityNotFoundException("");

        var response = handler.handleEntityNotFound(ex, request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
        checkBody(response.getBody(), 404, "handle.entity.not.found");
        verify(appLogService).log(any());
    }

    @Test
    void handleDataIntegrityViolation_shouldReturnConflictResponse() {
        mockMessage();
        DataIntegrityViolationException ex = new DataIntegrityViolationException("");

        var response = handler.handleDataIntegrityViolation(ex, request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CONFLICT);
        checkBody(response.getBody(), 409, "handle.data.integrity.violation");
        verify(appLogService).log(any());
    }

    @Test
    void handleUsernameNotFound_shouldReturnUnauthorizedResponse() {
        mockMessage();
        UsernameNotFoundException ex = new UsernameNotFoundException("");

        var response = handler.handleUsernameNotFound(ex, request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
        checkBody(response.getBody(), 401, "handle.username.not.found");
        verify(appLogService).log(any());
    }

    @Test
    void handleUserNotFoundById_shouldReturnNotFoundResponse() {
        mockMessage();
        UserNotFoundByIdException ex = new UserNotFoundByIdException("");

        var response = handler.handleUserNotFoundById(ex, request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
        checkBody(response.getBody(), 404, "handle.user.not.found.by.id");
        verify(appLogService).log(any());
    }

    @Test
    void handleEntityExists_shouldReturnConflictResponse() {
        mockMessage();
        EntityExistsException ex = new EntityExistsException("");

        var response = handler.handleEntityExists(ex, request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CONFLICT);
        checkBody(response.getBody(), 409, "handle.entity.exists");
        verify(appLogService).log(any());
    }

    @Test
    void handleHandlerMethodValidation_shouldReturnBadRequestResponse() {
        MethodValidationResult methodValidationResult = mock(MethodValidationResult.class);
        mockMessage();
        HandlerMethodValidationException ex = new HandlerMethodValidationException(methodValidationResult);

        var response = handler.handleHandlerMethodValidation(ex, request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
        checkBody(response.getBody(), 400, "handle.handler.method.validation");
        verify(appLogService).log(any());
    }

    @Test
    void handleIllegalArgument_shouldReturnBadRequestResponse() {
        mockMessage();
        IllegalArgumentException ex = new IllegalArgumentException("");

        var response = handler.handleIllegalArgument(ex, request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
        checkBody(response.getBody(), 400, "handle.illegal.argument");
        verify(appLogService).log(any());
    }

    @Test
    void handleMethodArgumentNotValid_shouldReturnBadRequestResponseWithValidationMessage() {
        MethodParameter parameter = mock(MethodParameter.class);
        BindingResult bindingResult = mock(BindingResult.class);
        FieldError fieldError1 = new FieldError("object", "email", "–ü–æ—á—Ç–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞");
        FieldError fieldError2 = new FieldError("object", "password", "–ü–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω");
        when(bindingResult.getFieldErrors()).thenReturn(List.of(fieldError1, fieldError2));
        mockMessage();
        MethodArgumentNotValidException ex = new MethodArgumentNotValidException(parameter, bindingResult);

        var response = handler.handleMethodArgumentNotValid(ex, request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
        ApiResponse<?> body = response.getBody();
        assertThat(body).isNotNull();
        assertThat(body.getMessage()).contains("–ü–æ—á—Ç–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞");
        assertThat(body.getMessage()).contains("–ü–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω");
        assertThat(body.getStatus()).isEqualTo(400);
    }

    @Test
    void handleMethodArgumentNotValid_shouldReturnBadRequestResponseWithDefaultMessage() {
        MethodParameter parameter = mock(MethodParameter.class);
        BindingResult bindingResult = mock(BindingResult.class);
        when(bindingResult.getFieldErrors()).thenReturn(List.of());
        mockMessage();
        MethodArgumentNotValidException ex = new MethodArgumentNotValidException(parameter, bindingResult);

        var response = handler.handleMethodArgumentNotValid(ex, request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
        ApiResponse<?> body = response.getBody();
        assertThat(body).isNotNull();
        assertThat(body.getMessage()).contains("validation.error");
        assertThat(body.getStatus()).isEqualTo(400);
    }

    @Test
    void handleMethodArgumentNotValid_shouldLogPrincipalNameWhenPresent() {
        request.setUserPrincipal(() -> "user");
        MethodParameter parameter = mock(MethodParameter.class);
        BindingResult bindingResult = mock(BindingResult.class);
        when(bindingResult.getFieldErrors()).thenReturn(List.of());
        mockMessage();
        MethodArgumentNotValidException ex = new MethodArgumentNotValidException(parameter, bindingResult);

        var response = handler.handleMethodArgumentNotValid(ex, request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
        ApiResponse<?> body = response.getBody();
        assertThat(body).isNotNull();
        assertThat(body.getMessage()).contains("validation.error").doesNotContain("null");
    }

    @Test
    void handleConstraintViolation_shouldReturnBadRequestResponseWithValidationMessage() {
        ConstraintViolation<?> v1 = mock(ConstraintViolation.class);
        ConstraintViolation<?> v2 = mock(ConstraintViolation.class);
        when(v1.getMessage()).thenReturn("–ü–æ—á—Ç–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞");
        when(v2.getMessage()).thenReturn("–ü–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω");
        ConstraintViolationException ex = new ConstraintViolationException(Set.of(v1, v2));

        var response = handler.handleConstraintViolation(ex, request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
        var body = response.getBody();
        assertThat(body).isNotNull();
        assertThat(body.getMessage()).contains("–ü–æ—á—Ç–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞");
        assertThat(body.getMessage()).contains("–ü–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω");
    }

    @Test
    void handleConstraintViolation_shouldReturnBadRequestResponseWithDefaultMessage() {
        mockMessage();
        ConstraintViolationException ex = new ConstraintViolationException(Set.of());

        var response = handler.handleConstraintViolation(ex, request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
        var body = response.getBody();
        assertThat(body).isNotNull();
        assertThat(body.getMessage()).contains("validation.error");
    }

    @Test
    void handleGeneric_shouldReturnInternalServerErrorResponse() {
        mockMessage();
        Exception ex = new RuntimeException("");

        var response = handler.handleGeneric(ex, request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
        ApiResponse<?> body = response.getBody();
        assertThat(body).isNotNull();
        assertThat(body.getStatus()).isEqualTo(500);
        assertThat(body.getMessage()).contains("handle.generic");
        verify(appLogService).log(any());
    }

    @Test
    void handleGeneric_shouldIncludeStackTraceFor5xxErrors() {
        mockMessage();
        request.setUserPrincipal(() -> "stack-user");
        Exception ex = new RuntimeException("Exception");

        var response = handler.handleGeneric(ex, request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().getStatus()).isEqualTo(500);
        verify(appLogService).log(any());
    }

    @Test
    void handleGeneric_shouldUseClassSimpleName_whenNoStackTrace() {
        mockMessage();

        Exception ex = new Exception("No stack trace");
        ex.setStackTrace(new StackTraceElement[0]);

        var response = handler.handleGeneric(ex, request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
        assertThat(response.getBody()).isNotNull();
        ArgumentCaptor<AppLogDto> appLogDtoCaptor = ArgumentCaptor.forClass(AppLogDto.class);
        verify(appLogService).log(appLogDtoCaptor.capture());
        AppLogDto savedDto = appLogDtoCaptor.getValue();
        assertThat(savedDto.getErrorType()).isEqualTo("Exception");
        assertThat(savedDto.getLevel()).isNotNull();
        assertThat(savedDto.getTimestamp()).isNotNull();
    }

    private void checkBody(ApiResponse<?> body, int status, String message) {
        assertThat(body).isNotNull();
        assertThat(body.getStatus()).isEqualTo(status);
        assertThat(body.getMessage()).contains(message);
        assertThat(body.getPath()).isEqualTo(API_TEST_ENDPOINT);
    }

    private void mockMessage() {
        when(messageSource.getMessage(anyString(), any(), any())).thenAnswer(invocation ->
                invocation.getArgument(0));
    }
}

package test.exception;

import com.example.expensetracker.exception.UnauthorizedException;
import org.junit.jupiter.api.Test;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.AuthenticationException;
import org.springframework.web.bind.annotation.ResponseStatus;

import static org.assertj.core.api.Assertions.assertThat;

public class UnauthorizedExceptionTest {
    @Test
    public void shouldStoreMessage() {
        String message = "User is not authorized";
        UnauthorizedException ex = new UnauthorizedException(message);

        assertThat(ex.getMessage()).isEqualTo(message);
        assertThat(ex).isInstanceOf(AuthenticationException.class);
    }

    @Test
    public void shouldBeAnnotatedWithUnauthorizedStatus() {
        ResponseStatus annotation = UnauthorizedException.class.getAnnotation(ResponseStatus.class);

        assertThat(annotation).isNotNull();
        assertThat(annotation.value()).isEqualTo(HttpStatus.UNAUTHORIZED);
    }
}

package test.logging.applog;

import com.example.expensetracker.logging.applog.AppLog;
import com.example.expensetracker.logging.applog.AppLogDto;
import nl.jqno.equalsverifier.EqualsVerifier;
import nl.jqno.equalsverifier.Warning;
import org.junit.jupiter.api.Test;
import test.util.TestData;

import java.time.Instant;
import java.time.temporal.ChronoUnit;

import static com.example.expensetracker.logging.applog.AppLogLevel.INFO;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.within;
import static test.util.Constants.*;

public class AppLogDtoTest {

    @Test
    void shouldCreateAppLogWithNoArgsConstructor() {
        AppLogDto appLogDto = new AppLogDto();

        assertThat(appLogDto).isNotNull();
    }

    @Test
    void shouldSetFieldsUsingConstructor() {
        AppLogDto applog = new AppLogDto();
        applog.setId(ID_STRING);
        applog.setTimestamp(Instant.now());
        applog.setLevel(INFO);
        applog.setLogger(LOGGER_TEST_DATA);
        applog.setMessage(TEST_MESSAGE);
        applog.setUserEmail(USER_EMAIL);
        applog.setEndPoint(API_TEST_ENDPOINT);
        applog.setErrorType(TYPE_ERROR_WARN);

        assertThat(applog.getTimestamp()).isCloseTo(Instant.now(), within(1, ChronoUnit.SECONDS));
        assertThat(applog).extracting(AppLogDto::getId, AppLogDto::getLevel, AppLogDto::getLogger,
                        AppLogDto::getMessage, AppLogDto::getUserEmail, AppLogDto::getEndPoint, AppLogDto::getErrorType)
                .containsExactly(ID_STRING, INFO, LOGGER_TEST_DATA, TEST_MESSAGE, USER_EMAIL, API_TEST_ENDPOINT,
                        TYPE_ERROR_WARN);
    }

    @Test
    void equalsHashCode_contract() {
        EqualsVerifier.forClass(AppLogDto.class)
                .withOnlyTheseFields("id", "timestamp", "level", "logger", "errorType", "message", "userEmail", "endPoint")
                .suppress(Warning.NONFINAL_FIELDS)
                .usingGetClass()
                .verify();
    }

    @Test
    void from_shouldMapAllFieldsCorrectly() {
        AppLog appLog = TestData.appLog();

        AppLogDto result = AppLogDto.from(appLog);

        assertThat(result.getTimestamp()).isCloseTo(Instant.now(), within(1, ChronoUnit.SECONDS));
        assertThat(result).extracting(AppLogDto::getId, AppLogDto::getLevel, AppLogDto::getLogger,
                        AppLogDto::getMessage, AppLogDto::getUserEmail, AppLogDto::getEndPoint, AppLogDto::getErrorType)
                .containsExactly(ID_STRING, INFO, LOGGER_TEST_DATA, TEST_MESSAGE, USER_EMAIL, API_TEST_ENDPOINT,
                        TYPE_ERROR_WARN);
    }
}

package test.logging.applog;

import com.example.expensetracker.logging.applog.AppLogDto;
import com.example.expensetracker.logging.applog.AppLogFilter;
import com.example.expensetracker.logging.applog.AppLogService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;

import java.lang.reflect.Method;

import static com.example.expensetracker.logging.applog.AppLogLevel.INFO;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.*;
import static test.util.Constants.API_TEST_ENDPOINT;
import static test.util.Constants.USER_EMAIL;

@ExtendWith(MockitoExtension.class)
public class AppLogFilterTest {
    
    @Mock
    private AppLogService appLogService;

    @Mock
    private HttpServletRequest request;

    @Mock
    private HttpServletResponse response;

    @Mock
    private FilterChain filterChain;

    @InjectMocks
    private AppLogFilter appLogFilter;

    @BeforeEach
    void setUp() {
        SecurityContextHolder.clearContext();
    }

    @AfterEach
    void tearDown() {
        SecurityContextHolder.clearContext();
    }

    @Test
    void doFilterInternal_shouldLogAnonymousUser() throws Exception {
        Method method = AppLogFilter.class.getDeclaredMethod("doFilterInternal",
                HttpServletRequest.class, HttpServletResponse.class, FilterChain.class);
        method.setAccessible(true);

        when(request.getMethod()).thenReturn("GET");
        when(request.getRequestURI()).thenReturn(API_TEST_ENDPOINT);
        when(response.getStatus()).thenReturn(200);

        method.invoke(appLogFilter, request, response, filterChain);

        ArgumentCaptor<AppLogDto> appLogCaptor = ArgumentCaptor.forClass(AppLogDto.class);
        verify(appLogService).log(appLogCaptor.capture());

        AppLogDto dto = appLogCaptor.getValue();

        assertThat(dto).extracting(AppLogDto::getLevel, AppLogDto::getLogger, AppLogDto::getUserEmail,
                        AppLogDto::getEndPoint)
                .containsExactly(INFO, "HTTP", "ANONYMOUS", API_TEST_ENDPOINT);
        assertThat(dto.getMessage()).contains("GET " + API_TEST_ENDPOINT + " -> 200 (").endsWith(" ms)");
    }

    @Test
    void doFilterInternal_shouldLogAuthenticationUser() throws Exception {
        Method method = AppLogFilter.class.getDeclaredMethod("doFilterInternal",
                HttpServletRequest.class, HttpServletResponse.class, FilterChain.class);
        method.setAccessible(true);

        Authentication auth = mock(Authentication.class);
        SecurityContext context = mock(SecurityContext.class);

        when(auth.isAuthenticated()).thenReturn(true);
        when(auth.getName()).thenReturn(USER_EMAIL);
        when(context.getAuthentication()).thenReturn(auth);
        when(auth.getName()).thenReturn(USER_EMAIL);
        SecurityContextHolder.setContext(context);

        when(request.getMethod()).thenReturn("GET");
        when(request.getRequestURI()).thenReturn(API_TEST_ENDPOINT);
        when(response.getStatus()).thenReturn(200);

        method.invoke(appLogFilter, request, response, filterChain);

        ArgumentCaptor<AppLogDto> appLogCaptor = ArgumentCaptor.forClass(AppLogDto.class);
        verify(appLogService).log(appLogCaptor.capture());

        AppLogDto dto = appLogCaptor.getValue();

        assertThat(dto).extracting(AppLogDto::getLevel, AppLogDto::getLogger, AppLogDto::getUserEmail,
                        AppLogDto::getEndPoint)
                .containsExactly(INFO, "HTTP", USER_EMAIL, API_TEST_ENDPOINT);
        assertThat(dto.getMessage()).contains("GET " + API_TEST_ENDPOINT + " -> 200 (").endsWith(" ms)");
    }

    @Test
    void doFilterInternal_shouldLogNotAuthenticationUser() throws Exception {
        Method method = AppLogFilter.class.getDeclaredMethod("doFilterInternal",
                HttpServletRequest.class, HttpServletResponse.class, FilterChain.class);
        method.setAccessible(true);

        Authentication auth = mock(Authentication.class);
        SecurityContext context = mock(SecurityContext.class);
        
        when(context.getAuthentication()).thenReturn(auth);
        SecurityContextHolder.setContext(context);

        when(request.getMethod()).thenReturn("GET");
        when(request.getRequestURI()).thenReturn(API_TEST_ENDPOINT);
        when(response.getStatus()).thenReturn(200);

        method.invoke(appLogFilter, request, response, filterChain);

        ArgumentCaptor<AppLogDto> appLogCaptor = ArgumentCaptor.forClass(AppLogDto.class);
        verify(appLogService).log(appLogCaptor.capture());

        AppLogDto dto = appLogCaptor.getValue();

        assertThat(dto).extracting(AppLogDto::getLevel, AppLogDto::getLogger, AppLogDto::getUserEmail,
                        AppLogDto::getEndPoint)
                .containsExactly(INFO, "HTTP", "ANONYMOUS", API_TEST_ENDPOINT);
        assertThat(dto.getMessage()).contains("GET " + API_TEST_ENDPOINT + " -> 200 (").endsWith(" ms)");
    }
}

package test.logging.applog;

import com.example.expensetracker.logging.applog.AppLog;
import com.example.expensetracker.logging.applog.AppLogDto;
import com.example.expensetracker.logging.applog.AppLogRepository;
import com.example.expensetracker.logging.applog.AppLogService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import test.util.TestData;

import java.util.List;

import static com.example.expensetracker.logging.applog.AppLogLevel.INFO;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.tuple;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static test.util.Constants.*;

@ExtendWith(MockitoExtension.class)
public class AppLogServiceTest {

    @Mock
    private AppLogRepository appLogRepository;

    @Mock
    private Pageable pageable;

    @InjectMocks
    private AppLogService appLogService;

    @Test
    void log_shouldSaveEntity() {
        AppLog appLog = TestData.appLog();
        AppLogDto appLogDto = AppLogDto.from(appLog);
        when(appLogRepository.save(any())).thenAnswer(invocation -> invocation.getArgument(0));

        AppLogDto result = appLogService.log(appLogDto);

        assertThat(result).extracting(AppLogDto::getId, AppLogDto::getLevel, AppLogDto::getLogger,
                        AppLogDto::getMessage, AppLogDto::getUserEmail, AppLogDto::getEndPoint, AppLogDto::getErrorType)
                .containsExactly(ID_STRING, INFO, LOGGER_TEST_DATA, TEST_MESSAGE, USER_EMAIL, API_TEST_ENDPOINT,
                        TYPE_ERROR_WARN);
        verify(appLogRepository).save(any());
    }

    @Test
    void findAll_shouldMapCorrectAndReturnPage() {
        AppLog appLog = TestData.appLog();
        Page<AppLog> appLogs = new PageImpl<>(List.of(appLog));
        when(appLogRepository.findAll(any(Pageable.class))).thenReturn(appLogs);

        var result = appLogService.findAll(pageable);

        assertThat(result.getContent()).hasSize(1);
        assertThat(result.getContent()).extracting(AppLogDto::getId, AppLogDto::getLevel, AppLogDto::getLogger,
                        AppLogDto::getMessage, AppLogDto::getUserEmail, AppLogDto::getEndPoint, AppLogDto::getErrorType)
                .containsExactly(tuple(ID_STRING, INFO, LOGGER_TEST_DATA, TEST_MESSAGE, USER_EMAIL, API_TEST_ENDPOINT,
                        TYPE_ERROR_WARN));
        verify(appLogRepository).findAll(any(Pageable.class));
    }

    @Test
    void findAll_shouldReturnEmptyPage() {
        when(appLogRepository.findAll(any(Pageable.class))).thenReturn(Page.empty());

        var result = appLogService.findAll(pageable);

        assertThat(result.getContent()).isEmpty();
        verify(appLogRepository).findAll(any(Pageable.class));
    }

    @Test
    void findByUserEmail_shouldMapCorrectAndReturnPage() {
        AppLog appLog = TestData.appLog();
        Page<AppLog> appLogs = new PageImpl<>(List.of(appLog));
        when(appLogRepository.findByUserEmail(eq(USER_EMAIL), any(Pageable.class))).thenReturn(appLogs);

        var result = appLogService.findByUserEmail(USER_EMAIL, pageable);

        assertThat(result.getContent()).hasSize(1);
        assertThat(result.getContent()).extracting(AppLogDto::getId, AppLogDto::getLevel, AppLogDto::getLogger,
                        AppLogDto::getMessage, AppLogDto::getUserEmail, AppLogDto::getEndPoint, AppLogDto::getErrorType)
                .containsExactly(tuple(ID_STRING, INFO, LOGGER_TEST_DATA, TEST_MESSAGE, USER_EMAIL, API_TEST_ENDPOINT,
                        TYPE_ERROR_WARN));
        verify(appLogRepository).findByUserEmail(eq(USER_EMAIL), any(Pageable.class));
    }

    @Test
    void findByUserEmail_shouldReturnEmptyPage() {
        when(appLogRepository.findByUserEmail(eq(USER_EMAIL), any(Pageable.class))).thenReturn(Page.empty());

        var result = appLogService.findByUserEmail(USER_EMAIL, pageable);

        assertThat(result.getContent()).isEmpty();
        verify(appLogRepository).findByUserEmail(eq(USER_EMAIL), any(Pageable.class));
    }
}

package test.logging.applog;

import com.example.expensetracker.logging.applog.AppLog;
import com.example.expensetracker.logging.applog.AppLogDto;
import org.junit.jupiter.api.Test;
import test.util.TestData;

import java.time.Instant;
import java.time.temporal.ChronoUnit;

import static com.example.expensetracker.logging.applog.AppLogLevel.INFO;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.within;
import static test.util.Constants.*;
import static test.util.Constants.TYPE_ERROR_WARN;

public class AppLogTest {

    @Test
    void shouldCreateAppLogWithNoArgsConstructor() {
        AppLog appLog = new AppLog();

        assertThat(appLog).isNotNull();
    }

    @Test
    void shouldSetFieldsUsingSetters() {
        AppLog applog = new AppLog();
        applog.setId(ID_STRING);
        applog.setTimestamp(Instant.now());
        applog.setLevel(INFO);
        applog.setLogger(LOGGER_TEST_DATA);
        applog.setMessage(TEST_MESSAGE);
        applog.setUserEmail(USER_EMAIL);
        applog.setEndPoint(API_TEST_ENDPOINT);
        applog.setErrorType(TYPE_ERROR_WARN);

        assertThat(applog.getTimestamp()).isCloseTo(Instant.now(), within(1, ChronoUnit.SECONDS));
        assertThat(applog).extracting(AppLog::getId, AppLog::getLevel, AppLog::getLogger,
                        AppLog::getMessage, AppLog::getUserEmail, AppLog::getEndPoint, AppLog::getErrorType)
                .containsExactly(ID_STRING, INFO, LOGGER_TEST_DATA, TEST_MESSAGE, USER_EMAIL, API_TEST_ENDPOINT,
                        TYPE_ERROR_WARN);
    }

    @Test
    void from_shouldMapAllFieldsCorrectly() {
        AppLogDto appLogDto = TestData.appLogDto();

        AppLog result = AppLog.from(appLogDto);

        assertThat(result.getTimestamp()).isCloseTo(Instant.now(), within(1, ChronoUnit.SECONDS));
        assertThat(result).extracting(AppLog::getId, AppLog::getLevel, AppLog::getLogger,
                        AppLog::getMessage, AppLog::getUserEmail, AppLog::getEndPoint, AppLog::getErrorType)
                .containsExactly(ID_STRING, INFO, LOGGER_TEST_DATA, TEST_MESSAGE, USER_EMAIL, API_TEST_ENDPOINT,
                        TYPE_ERROR_WARN);
    }
}

package test.logging.audit;

import com.example.expensetracker.logging.audit.Audit;
import com.example.expensetracker.logging.audit.AuditDto;
import nl.jqno.equalsverifier.EqualsVerifier;
import org.junit.jupiter.api.Test;
import test.util.TestData;

import java.time.Instant;
import java.time.temporal.ChronoUnit;

import static com.example.expensetracker.logging.audit.AuditAction.BAN;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.within;
import static test.util.Constants.*;

public class AuditDtoTest {

    @Test
    void constructor_shouldSetAllFieldsCorrectly() {
        Instant now = Instant.now();
        AuditDto dto = new AuditDto(ID_VALID, BAN, USER_EMAIL, ADMIN_EMAIL, now);

        assertThat(dto.getTimeStamp()).isEqualTo(now);
        assertThat(dto.getId()).isEqualTo(ID_VALID);
        assertThat(dto.getAction()).isEqualTo(BAN);
        assertThat(dto.getTargetUser()).isEqualTo(USER_EMAIL);
        assertThat(dto.getPerformedBy()).isEqualTo(ADMIN_EMAIL);
    }

    @Test
    void equalsHashCode_contract() {
        EqualsVerifier.forClass(AuditDto.class)
                .withOnlyTheseFields("action", "targetUserEmail", "performedByEmail", "timeStamp")
                .usingGetClass()
                .verify();
    }

    @Test
    void from_shouldReturnEntity() {
        Audit audit = new Audit(BAN, TestData.user(), TestData.admin());
        audit.setId(1L);
        audit.setTimeStamp(Instant.now());

        var dto = AuditDto.from(audit);

        assertThat(dto.getId()).isEqualTo(audit.getId());
        assertThat(dto.getAction()).isEqualTo(BAN);
        assertThat(dto.getTargetUser()).isEqualTo(audit.getTargetUser().getEmail());
        assertThat(dto.getPerformedBy()).isEqualTo(audit.getPerformedBy().getEmail());
        assertThat(dto.getTimeStamp()).isCloseTo(Instant.now(), within(1, ChronoUnit.SECONDS));
    }
}

package test.logging.audit;

import com.example.expensetracker.logging.audit.Audit;
import com.example.expensetracker.logging.audit.AuditRepository;
import com.example.expensetracker.logging.audit.AuditService;
import com.example.expensetracker.model.User;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import test.util.TestData;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.List;

import static com.example.expensetracker.logging.audit.AuditAction.BAN;
import static com.example.expensetracker.logging.audit.AuditAction.CHANGE_PASSWORD;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.within;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import static test.util.Constants.*;

@ExtendWith(MockitoExtension.class)
public class AuditServiceTest {

    @Mock
    private AuditRepository auditRepository;

    @InjectMocks
    private AuditService auditService;

    @Test
    void logAction_shouldSaveAndReturnDto() {
        User targetUser = TestData.user();
        User admin = TestData.admin();
        Audit audit = new Audit(BAN, targetUser, admin);
        audit.setId(1L);
        audit.setTimeStamp(Instant.now());

        when(auditRepository.save(any(Audit.class))).thenAnswer(invocation -> invocation.getArgument(0));

        var result = auditService.logAction(BAN, targetUser, admin);

        assertThat(result.getAction()).isEqualTo(BAN);
        assertThat(result.getTargetUser()).isEqualTo(USER_EMAIL);
        assertThat(result.getPerformedBy()).isEqualTo(ADMIN_EMAIL);
        verify(auditRepository).save(any(Audit.class));
    }

    @Test
    void getAll_shouldReturnMappedPage() {
        User targetUser = TestData.user();
        User admin = TestData.admin();
        Audit audit = new Audit(BAN, targetUser, admin);
        Page<Audit> audits = new PageImpl<>(List.of(audit));
        when(auditRepository.findAll(any(Pageable.class))).thenReturn(audits);

        var result = auditService.getAll(PageRequest.of(0, 10));

        assertThat(result.getContent()).hasSize(1);
        assertThat(result.getContent().get(0).getAction()).isEqualTo(BAN);
        verify(auditRepository).findAll(any(PageRequest.class));
    }

    @Test
    void getByAdmin_shouldReturnMappedPage() {
        User targetUser = TestData.user();
        User admin = TestData.admin();
        Audit audit = new Audit(BAN, targetUser, admin);
        Page<Audit> audits = new PageImpl<>(List.of(audit));
        when(auditRepository.findByPerformedBy_Id(eq(ID_ADMIN), any(Pageable.class))).thenReturn(audits);

        var result = auditService.getByAdmin(ID_ADMIN, PageRequest.of(0, 10));

        assertThat(result.getContent()).hasSize(1);
        assertThat(result.getContent().get(0).getAction()).isEqualTo(BAN);
        verify(auditRepository).findByPerformedBy_Id(eq(ID_ADMIN), any(PageRequest.class));
    }

    @Test
    void logPasswordChange_shouldSaveAudit() {
        User user = TestData.user();

        auditService.logPasswordChange(user);
        
        ArgumentCaptor<Audit> auditCaptor = ArgumentCaptor.forClass(Audit.class);
        verify(auditRepository).save(auditCaptor.capture());

        Audit audit = auditCaptor.getValue();

        assertThat(audit.getAction()).isEqualTo(CHANGE_PASSWORD);
        assertThat(audit.getTargetUser()).isEqualTo(user);
        assertThat(audit.getPerformedBy()).isEqualTo(user);
        assertThat(audit.getTimeStamp()).isNotNull();
        assertThat(audit.getTimeStamp()).isCloseTo(Instant.now(), within(1, ChronoUnit.SECONDS));
    }
}

package test.logging.audit;

import com.example.expensetracker.logging.audit.AuditAction;
import com.example.expensetracker.logging.audit.Audit;
import com.example.expensetracker.model.User;
import org.junit.jupiter.api.Test;
import test.util.TestData;

import java.lang.reflect.Method;
import java.time.Instant;
import java.time.temporal.ChronoUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.within;
import static test.util.Constants.ADMIN_EMAIL;

public class AuditTest {

    @Test
    void constructor_shouldSetFieldsUsing() {
        Audit audit = new Audit(AuditAction.BAN, TestData.user(), TestData.admin());

        assertThat(audit.getAction()).isEqualTo(AuditAction.BAN);
        assertThat(audit.getTargetUser().getId()).isEqualTo(42L);
        assertThat(audit.getPerformedBy().getEmail()).isEqualTo(ADMIN_EMAIL);
    }

    @Test
    void setters_shouldSetAllFieldsCorrectly() {
        Audit audit = new Audit();
        Instant now = Instant.now();
        User targetUser = TestData.user();
        User performedBy = TestData.admin();

        audit.setId(1L);
        audit.setAction(AuditAction.UNBAN);
        audit.setTargetUser(targetUser);
        audit.setPerformedBy(performedBy);
        audit.setTimeStamp(now);

        assertThat(audit.getId()).isEqualTo(1L);
        assertThat(audit.getAction()).isEqualTo(AuditAction.UNBAN);
        assertThat(audit.getTargetUser()).extracting(User::getId, User::getEmail)
                .containsExactly(targetUser.getId(), targetUser.getEmail());
        assertThat(audit.getPerformedBy()).extracting(User::getId, User::getEmail)
                .containsExactly(performedBy.getId(), performedBy.getEmail());
        assertThat(audit.getTimeStamp()).isEqualTo(now);
    }

    @Test
    void shouldSetDefaultIdAndTimeStamp() {
        Audit audit = new Audit();

        assertThat(audit.getId()).isNull();
        assertThat(audit.getTimeStamp()).isNotNull();
        assertThat(audit.getTimeStamp()).isCloseTo(Instant.now(), within(1, ChronoUnit.SECONDS));
    }

    @Test
    void shouldSetIdAndTimeStamp() throws Exception {
        Audit audit = new Audit();
        Method method = Audit.class.getDeclaredMethod("onCreate");
        method.setAccessible(true);
        method.invoke(audit);

        assertThat(audit.getTimeStamp()).isCloseTo(Instant.now(), within(1, ChronoUnit.SECONDS));
    }
}

package test;

import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
public class LogServiceTest {
}

package test.model;

import com.example.expensetracker.model.Category;
import nl.jqno.equalsverifier.EqualsVerifier;
import nl.jqno.equalsverifier.Warning;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;
import static test.util.Constants.CATEGORY_NAME;
import static test.util.Constants.ID_VALID;

public class CategoryTest {
    @Test
    void settersAndGetters() {
        Category category = new Category();

        category.setId(ID_VALID);
        category.setName(CATEGORY_NAME);

        assertThat(category.getId()).isEqualTo(ID_VALID);
        assertThat(category.getName()).isEqualTo(CATEGORY_NAME);
    }

    @Test
    void allArgsConstructor_shouldSetAllFields() {
        Category category = new Category(CATEGORY_NAME);

        assertThat(category.getName()).isEqualTo(CATEGORY_NAME);
    }

    @Test
    void equalsHashCode_contract() {
        EqualsVerifier.forClass(Category.class)
                .usingGetClass()
                .suppress(Warning.SURROGATE_KEY)
                .verify();
    }

    @Test
    void toStringTest() {
        Category category = new Category();
        assertThat(category).asString().contains("id").contains("name");
    }
}

package test.model;

import com.example.expensetracker.model.Category;
import com.example.expensetracker.model.Expense;
import com.example.expensetracker.model.Role;
import com.example.expensetracker.model.User;
import org.junit.jupiter.api.Test;
import test.util.TestData;

import java.math.BigDecimal;
import java.time.Instant;

import static org.assertj.core.api.Assertions.assertThat;
import static test.util.Constants.*;

public class ExpenseTest {

    @Test
    void settersAndGetters() {
        User user = TestData.user();
        BigDecimal amount = new BigDecimal("0");
        Expense expense = new Expense();
        Instant occurredAt = Instant.now();
        Category category = new Category(CATEGORY_NAME);
        
        expense.setId(ID_EXPENSE);
        expense.setUser(user);
        expense.setAmount(amount);
        expense.setOccurredAt(occurredAt);
        expense.setCategory(category);
        expense.setDescription(DESCRIPTION);

        assertThat(expense.getId()).isEqualTo(ID_EXPENSE);
        assertThat(expense.getUser()).satisfies(u -> {
                assertThat(u.getId()).isEqualTo(ID_VALID);
                assertThat(u.getEmail()).isEqualTo(USER_EMAIL);
                assertThat(u.getPassword()).isEqualTo(USER_PASSWORD);
                assertThat(u.isBanned()).isFalse();
                assertThat(u.getRoles()).contains(Role.USER);
        });
        assertThat(expense.getAmount()).isEqualByComparingTo(amount);
        assertThat(expense.getOccurredAt()).isEqualTo(occurredAt);
        assertThat(expense.getCategory().getName()).isEqualTo(category.getName());
        assertThat(expense.getDescription()).isEqualTo(DESCRIPTION);
    }
    
    @Test
    void allArgsConstructor_shouldSetAllFields() {
        User user = TestData.user();
        Category category = new Category(CATEGORY_NAME);
        BigDecimal amount = new BigDecimal("0");
        Instant now = Instant.now();
        
        Expense expense = new Expense(ID_EXPENSE, user, amount, now, category, DESCRIPTION);
        
        assertThat(expense.getId()).isEqualTo(ID_EXPENSE);
        assertThat(expense.getUser()).isEqualTo(user);
        assertThat(expense.getAmount()).isEqualByComparingTo(amount);
        assertThat(expense.getOccurredAt()).isEqualTo(now);
        assertThat(expense.getCategory()).isEqualTo(category);
        assertThat(expense.getDescription()).isEqualTo(DESCRIPTION);
    }
}

package test.model;

import com.example.expensetracker.model.Category;
import com.example.expensetracker.model.RecurringTransaction;
import com.example.expensetracker.model.User;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.ValidatorFactory;
import nl.jqno.equalsverifier.EqualsVerifier;
import nl.jqno.equalsverifier.Warning;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.time.LocalDate;

import static org.assertj.core.api.Assertions.assertThat;
import static test.util.Constants.*;

public class RecurringTransactionTest {

    private static Validator validator;

    @BeforeAll
    static void setUpValidator() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    void constructor_shouldSuccess_whenAllFieldsValid() {
        BigDecimal amount = new BigDecimal(AMOUNT);
        Category category = new Category();
        User user = new User();
        LocalDate executionDate = LocalDate.now().minusDays(1);
        RecurringTransaction transaction = new RecurringTransaction(amount, DESCRIPTION, category,
                user, INTERVAL_DAYS, executionDate);

        assertThat(transaction).extracting(
                        RecurringTransaction::getAmount,
                        RecurringTransaction::getDescription,
                        RecurringTransaction::getCategory,
                        RecurringTransaction::getUser,
                        RecurringTransaction::getIntervalDays,
                        RecurringTransaction::getNextExecutionDate)
                .containsExactly(
                        amount,
                        DESCRIPTION,
                        category,
                        user,
                        INTERVAL_DAYS,
                        executionDate
                );
    }

    @Test
    void setters_shouldSuccess_whenAllFieldsValid() {
        BigDecimal amount = new BigDecimal(AMOUNT);
        Category category = new Category();
        User user = new User();
        LocalDate executionDate = LocalDate.now().minusDays(1);
        RecurringTransaction transaction = new RecurringTransaction();
        transaction.setAmount(amount);
        transaction.setDescription(DESCRIPTION);
        transaction.setCategory(category);
        transaction.setUser(user);
        transaction.setIntervalDays(INTERVAL_DAYS);
        transaction.setNextExecutionDate(executionDate);

        assertThat(transaction).extracting(
                        RecurringTransaction::getAmount,
                        RecurringTransaction::getDescription,
                        RecurringTransaction::getCategory,
                        RecurringTransaction::getUser,
                        RecurringTransaction::getIntervalDays,
                        RecurringTransaction::getNextExecutionDate)
                .containsExactly(
                        amount,
                        DESCRIPTION,
                        category,
                        user,
                        INTERVAL_DAYS,
                        executionDate
                );
    }

    @Test
    void equalsHashCode_contract() {
        EqualsVerifier.forClass(RecurringTransaction.class)
                .usingGetClass()
                .suppress(Warning.SURROGATE_KEY, Warning.IDENTICAL_COPY_FOR_VERSIONED_ENTITY)
                .verify();
    }
}

package test.model;

import com.example.expensetracker.dto.LoginDto;
import com.example.expensetracker.model.Category;
import com.example.expensetracker.model.Role;
import com.example.expensetracker.model.User;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.ValidatorFactory;
import nl.jqno.equalsverifier.EqualsVerifier;
import nl.jqno.equalsverifier.Warning;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import test.util.TestUtils;

import java.math.BigDecimal;
import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;
import static test.util.Constants.*;
import static test.util.TestMessageSource.msg;

public class UserTest {

    private static Validator validator;

    @BeforeAll
    static void setUpValidator() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    void shouldPass_whenAllFieldsValid() {
        User user = new User(ID_VALID, USER_EMAIL, USER_PASSWORD, Set.of(Role.USER), true);
        Set<ConstraintViolation<User>> violations = validator.validate(user);

        assertThat(violations).isEmpty();
    }

    @Test
    void shouldFail_whenEmailInvalid() {
        User user = new User(ID_VALID, "not-email", USER_PASSWORD, Set.of(Role.USER), true);
        Set<ConstraintViolation<User>> violations = validator.validate(user);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "email", msg("user.email.invalid")); 
    }

    @Test
    void shouldFail_whenEmailIsNull() {
        User user = new User(ID_VALID, null, USER_PASSWORD, Set.of(Role.USER), true);
        Set<ConstraintViolation<User>> violations = validator.validate(user);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "email", msg("user.email.not-blank"));
    }

    @Test
    void shouldFail_whenEmailIsEmpty() {
        User user = new User(ID_VALID, "", USER_PASSWORD, Set.of(Role.USER), true);
        Set<ConstraintViolation<User>> violations = validator.validate(user);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "email", msg("user.email.not-blank"));
    }

    @Test
    void shouldFail_whenPasswordIsNull() {
        User user = new User(ID_VALID, USER_EMAIL, null, Set.of(Role.USER), true);
        Set<ConstraintViolation<User>> violations = validator.validate(user);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "password", msg("user.password.not-blank"));
    }

    @Test
    void shouldFail_whenPasswordIsEmpty() {
        User user = new User(ID_VALID, USER_EMAIL, "", Set.of(Role.USER), true);
        Set<ConstraintViolation<User>> violations = validator.validate(user);

        assertThat(violations).hasSize(1);
        TestUtils.assertHasViolation(violations, "password", msg("user.password.not-blank"));
    }

    @Test
    void shouldInitializeRolesAsEmptySetByDefault() {
        User user = new User();

        assertThat(user.getRoles()).isNotNull().isEmpty();
    }

    @Test
    void setters_shouldSetAllFieldsCorrectly() {
        BigDecimal amount = new BigDecimal("0");
        User user = new User();

        user.setId(ID_VALID);
        user.setEmail(MODERATOR_EMAIL);
        user.setPassword(USER_PASSWORD);
        user.setRoles(Set.of(Role.MODERATOR));
        user.setBanned(false);
        user.setTotalExpenses(amount);

        assertThat(user.getId()).isEqualTo(ID_VALID);
        assertThat(user.getEmail()).isEqualTo(MODERATOR_EMAIL);
        assertThat(user.getPassword()).isEqualTo(USER_PASSWORD);
        assertThat(user.getRoles().iterator().next()).isEqualTo(Role.MODERATOR);
        assertThat(user.isBanned()).isFalse();
        assertThat(user.getTotalExpenses()).isEqualByComparingTo(amount);
    }

    @Test
    void shouldBuildUserUsingBuilder() {
        User user = User.builder()
                .id(ID_VALID)
                .email(USER_EMAIL)
                .password(USER_PASSWORD)
                .roles(Set.of(Role.USER))
                .banned(true)
                .build();

        assertThat(user.getId()).isEqualTo(ID_VALID);
        assertThat(user.getEmail()).isEqualTo(USER_EMAIL);
        assertThat(user.getPassword()).isEqualTo(USER_PASSWORD);
        assertThat(user.getRoles()).containsExactly(Role.USER);
        assertThat(user.isBanned()).isTrue();
    }

    @Test
    void equalsHashCode_contract() {
        EqualsVerifier.forClass(User.class)
                .usingGetClass()
                .suppress(Warning.SURROGATE_KEY, Warning.IDENTICAL_COPY_FOR_VERSIONED_ENTITY)
                .verify();
    }
}

package test.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.example.expensetracker.dto.ApiResponse;
import com.example.expensetracker.security.CustomAccessDeniedHandler;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.HttpStatus;
import org.springframework.security.access.AccessDeniedException;

import java.io.ByteArrayOutputStream;
import java.time.Instant;
import java.time.temporal.ChronoUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.within;
import static org.mockito.Mockito.*;
import static test.util.TestUtils.writeByteToStream;

@ExtendWith(MockitoExtension.class)
public class CustomAccessDeniedHandlerTest {

    private ObjectMapper objectMapper;
    private CustomAccessDeniedHandler handler;
    private Instant now = Instant.now();

    @BeforeEach
    void setUp() {
        objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        handler = new CustomAccessDeniedHandler(objectMapper);
    }

    @Test
    public void shouldReturnForbiddenResponse_whenAccessDenied() throws Exception {
        HttpServletRequest request = mock(HttpServletRequest.class);
        HttpServletResponse response = mock(HttpServletResponse.class);
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        when(request.getRequestURI()).thenReturn("/api/admin/users");
        when(response.getOutputStream()).thenReturn(writeByteToStream(baos));

        handler.handle(request, response, new AccessDeniedException("Forbidden"));

        verify(response).setStatus(HttpServletResponse.SC_FORBIDDEN);
        verify(response).setContentType("application/json");

        String json = baos.toString();
        var apiResponse = objectMapper.readValue(json, ApiResponse.class);

        assertThat(apiResponse.getTimestamp()).isCloseTo(Instant.now(), within(1, ChronoUnit.SECONDS));
        assertThat(apiResponse.getStatus()).isEqualTo(HttpStatus.FORBIDDEN.value());
        assertThat(apiResponse.getError()).isEqualTo(HttpStatus.FORBIDDEN.getReasonPhrase());
        assertThat(apiResponse.getMessage()).isEqualTo("–£ –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É —Ä–µ—Å—É—Ä—Å—É");
        assertThat(apiResponse.getPath()).isEqualTo("/api/admin/users");
    }

    @Test
    public void shouldReturnForbiddenResponse_whenRequestUriIsNull() throws Exception {
        HttpServletRequest request = mock(HttpServletRequest.class);
        HttpServletResponse response = mock(HttpServletResponse.class);
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        when(request.getRequestURI()).thenReturn(null);
        when(response.getOutputStream()).thenReturn(writeByteToStream(baos));

        handler.handle(request, response, new AccessDeniedException("Forbidden"));

        verify(response).setStatus(HttpServletResponse.SC_FORBIDDEN);
        verify(response).setContentType("application/json");

        String json = baos.toString();
        var apiResponse = objectMapper.readValue(json, ApiResponse.class);

        assertThat(apiResponse.getTimestamp()).isCloseTo(Instant.now(), within(1, ChronoUnit.SECONDS));
        assertThat(apiResponse.getStatus()).isEqualTo(HttpStatus.FORBIDDEN.value());
        assertThat(apiResponse.getError()).isEqualTo(HttpStatus.FORBIDDEN.getReasonPhrase());
        assertThat(apiResponse.getMessage()).isEqualTo("–£ –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É —Ä–µ—Å—É—Ä—Å—É");
        assertThat(apiResponse.getPath()).isEqualTo(null);
    }
}

package test.security;


import com.example.expensetracker.dto.ApiResponse;
import com.example.expensetracker.security.CustomAuthEntryPoint;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.HttpStatus;
import org.springframework.security.authentication.AuthenticationCredentialsNotFoundException;

import java.io.ByteArrayOutputStream;
import java.time.Instant;
import java.time.temporal.ChronoUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.within;
import static org.mockito.Mockito.*;
import static test.util.TestUtils.writeByteToStream;

@ExtendWith(MockitoExtension.class)
public class CustomAuthEntryPointTest {

    private ObjectMapper objectMapper;
    private CustomAuthEntryPoint customAuthEntryPoint;
    private Instant now = Instant.now();

    @BeforeEach
    void setUp() {
        objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        customAuthEntryPoint = new CustomAuthEntryPoint(objectMapper);
    }

    @Test
    public void commence_shouldReturnUnauthorizedResponse_whenAuthenticationFails() throws Exception {
        HttpServletRequest request = mock(HttpServletRequest.class);
        HttpServletResponse response = mock(HttpServletResponse.class);
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        when(request.getRequestURI()).thenReturn("/api/auth/login");
        when(response.getOutputStream()).thenReturn(writeByteToStream(baos));

        customAuthEntryPoint.commence(request, response,
                new AuthenticationCredentialsNotFoundException("No auth"));

        verify(response).setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        verify(response).setContentType("application/json");

        String json = baos.toString();
        var apiResponse = objectMapper.readValue(json, ApiResponse.class);

        assertThat(apiResponse.getTimestamp()).isCloseTo(Instant.now(), within(1, ChronoUnit.SECONDS));
        assertThat(apiResponse.getStatus()).isEqualTo(HttpStatus.UNAUTHORIZED.value());
        assertThat(apiResponse.getError()).isEqualTo(HttpStatus.UNAUTHORIZED.getReasonPhrase());
        assertThat(apiResponse.getMessage()).isEqualTo("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω: —Ç—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è");
        assertThat(apiResponse.getPath()).isEqualTo("/api/auth/login");
    }

    @Test
    public void commence_shouldReturnUnauthorizedResponse_whenRequestUriIsNull() throws Exception {
        HttpServletRequest request = mock(HttpServletRequest.class);
        HttpServletResponse response = mock(HttpServletResponse.class);
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        when(request.getRequestURI()).thenReturn(null);
        when(response.getOutputStream()).thenReturn(writeByteToStream(baos));

        customAuthEntryPoint.commence(request, response,
                new AuthenticationCredentialsNotFoundException("No auth"));

        verify(response).setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        verify(response).setContentType("application/json");

        String json = baos.toString();
        var apiResponse = objectMapper.readValue(json, ApiResponse.class);

        assertThat(apiResponse.getTimestamp()).isCloseTo(Instant.now(), within(1, ChronoUnit.SECONDS));
        assertThat(apiResponse.getStatus()).isEqualTo(HttpStatus.UNAUTHORIZED.value());
        assertThat(apiResponse.getError()).isEqualTo(HttpStatus.UNAUTHORIZED.getReasonPhrase());
        assertThat(apiResponse.getMessage()).isEqualTo("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω: —Ç—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è");
        assertThat(apiResponse.getPath()).isEqualTo(null);
    }
}

package test.security;

import com.example.expensetracker.details.UserDetailsImpl;
import com.example.expensetracker.model.User;
import com.example.expensetracker.repository.UserRepository;
import com.example.expensetracker.security.CustomUserDetailsService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import test.util.TestData;

import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.when;
import static test.util.Constants.USER_EMAIL;

@ExtendWith(MockitoExtension.class)
public class CustomUserDetailsServiceTest {

    @Mock
    private UserRepository userRepository;

    @InjectMocks
    CustomUserDetailsService customUserDetailsService;

    @Test
    void loadUserByUsername_shouldReturnUserDetails_whenUserExist() {
        User user = TestData.user();
        when(userRepository.findByEmail(USER_EMAIL)).thenReturn(Optional.of(user));

        var userDetails = customUserDetailsService.loadUserByUsername(USER_EMAIL);

        assertThat(userDetails).isNotNull().isInstanceOf(UserDetailsImpl.class);
        assertThat(userDetails.getUsername()).isEqualTo(user.getEmail());
    }

    @Test
    void loadUserByUsername_shouldThrowException_whenUserNotExist() {
        when(userRepository.findByEmail(USER_EMAIL)).thenReturn(Optional.empty());

        assertThrows(UsernameNotFoundException.class, () ->
                customUserDetailsService.loadUserByUsername(USER_EMAIL));
    }
}

package test.security;

import com.example.expensetracker.details.UserDetailsImpl;
import com.example.expensetracker.model.User;
import com.example.expensetracker.security.CustomUserDetailsService;
import com.example.expensetracker.security.JwtAuthFilter;
import com.example.expensetracker.security.JwtUtil;
import jakarta.servlet.FilterChain;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockHttpServletResponse;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import test.util.TestData;

import java.lang.reflect.Method;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.*;
import static test.util.Constants.API_USERS_ME;
import static test.util.Constants.USER_EMAIL;

@ExtendWith(MockitoExtension.class)
public class JwtAuthFilterTest {

    @Mock
    private JwtUtil jwtUtil;

    @Mock
    private CustomUserDetailsService userDetailsService;

    @Mock
    private FilterChain filterChain;

    @InjectMocks
    private JwtAuthFilter jwtAuthFilter;

    private Method doFilterInternal;
    private Method resolveToken;

    @BeforeEach
    void setUp() throws Exception {
        doFilterInternal = JwtAuthFilter.class.getDeclaredMethod("doFilterInternal",
                HttpServletRequest.class, HttpServletResponse.class, FilterChain.class);
        doFilterInternal.setAccessible(true);

        resolveToken = JwtAuthFilter.class.getDeclaredMethod("resolveToken",
                HttpServletRequest.class);
        resolveToken.setAccessible(true);
    }

    @AfterEach
    void tearDown() {
        SecurityContextHolder.clearContext();
    }

    @ParameterizedTest
    @ValueSource(strings = {"/webjars", "/v3/api-docs", "/swagger-ui", "/api/auth"})
    void doFilterInternal_shouldSkipAuthentication_whenPathWebjars(String path) throws Exception {
        MockHttpServletRequest request = new MockHttpServletRequest();
        MockHttpServletResponse response = new MockHttpServletResponse();
        request.setRequestURI(path);

        doFilterInternal.invoke(jwtAuthFilter, request, response, filterChain);

        verify(filterChain).doFilter(request, response);
        verifyNoInteractions(jwtUtil, userDetailsService);
    }

    @Test
    void resolveToken_shouldReturnToken_whenHeaderIsCorrect() throws Exception {
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.addHeader("Authorization", "Bearer token");

        String result = callResolveToken(request);

        assertThat(result).isEqualTo("token");
    }

    @Test
    void resolveToken_shouldReturnNull_whenHeaderIsNull() throws Exception {
        MockHttpServletRequest request = new MockHttpServletRequest();

        String result = callResolveToken(request);

        assertThat(result).isNull();
    }

    @Test
    void resolveToken_shouldReturnNull_whenHeaderStartsWithNotBearer() throws Exception {
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.addHeader("Authorization", "token");

        String result = callResolveToken(request);

        assertThat(result).isNull();
    }

    @Test
    void doFilterInternal_shouldSetAuthentication_whenValidTokenAndNoAuthInContext() throws Exception {
        String token = "valid.token";
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.addHeader("Authorization", "Bearer " + token);
        MockHttpServletResponse response = new MockHttpServletResponse();
        User user = TestData.user();
        UserDetailsImpl userDetails = new UserDetailsImpl(user);

        when(userDetailsService.loadUserByUsername(USER_EMAIL)).thenReturn(userDetails);
        when(jwtUtil.getSubject(token)).thenReturn(USER_EMAIL);

        doFilterInternal.invoke(jwtAuthFilter, request, response, filterChain);

        var auth = SecurityContextHolder.getContext().getAuthentication();
        assertThat(auth).isNotNull();
        assertThat(auth).isInstanceOf(UsernamePasswordAuthenticationToken.class);
        assertThat(auth.getName()).isEqualTo(USER_EMAIL);
        verify(filterChain).doFilter(request, response);
    }

    @Test void doFilterInternal_shouldResponseUnauthorized_whenTokenNotPresentAndContextEmpty() throws Exception { 
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setRequestURI(API_USERS_ME);
        MockHttpServletResponse response = new MockHttpServletResponse();
        SecurityContextHolder.clearContext();
        
        doFilterInternal.invoke(jwtAuthFilter, request, response, filterChain);
        
        assertThat(response.getStatus()).isEqualTo(HttpServletResponse.SC_UNAUTHORIZED);
        verify(jwtUtil, never()).getSubject(anyString());
        verify(userDetailsService, never()).loadUserByUsername(anyString());
        verify(filterChain, never()).doFilter(request, response);
    }

    @Test
    void doFilterInternal_shouldDoNothing_whenNoAuthorizationHeader() throws Exception {
        MockHttpServletRequest request = new MockHttpServletRequest();
        MockHttpServletResponse response = new MockHttpServletResponse();

        doFilterInternal.invoke(jwtAuthFilter, request, response, filterChain);

        assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
        verify(jwtUtil, never()).parse(anyString());
        verify(filterChain, never()).doFilter(eq(request), eq(response));
    }

    @Test
    void doFilterInternal_shouldSkipJwtParsing_whenNoTokenAndUserAuthenticated() throws Exception {
        MockHttpServletRequest request = new MockHttpServletRequest();
        MockHttpServletResponse response = new MockHttpServletResponse();
        User user = TestData.user();
        UserDetailsImpl userDetails = new UserDetailsImpl(user);

        UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(userDetails,
                null, userDetails.getAuthorities());
        SecurityContextHolder.getContext().setAuthentication(auth);

        doFilterInternal.invoke(jwtAuthFilter, request, response, filterChain);
        
        var currentAuth = SecurityContextHolder.getContext().getAuthentication();
        assertThat(currentAuth).isEqualTo(auth);
        verify(jwtUtil, never()).getSubject(any());
        verify(userDetailsService, never()).loadUserByUsername(any());
        verify(filterChain).doFilter(request, response);
    }

    @Test
    void doFilterInternal_shouldSkipJwtParsing_whenTokenPresentAndUserAuthenticated() throws Exception {
        String token = "valid.token";
        MockHttpServletRequest request = new MockHttpServletRequest();
        MockHttpServletResponse response = new MockHttpServletResponse();
        request.addHeader("Authorization","Bearer " + token);
        User user = TestData.user();
        UserDetailsImpl userDetails = new UserDetailsImpl(user);

        UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(userDetails,
                null, userDetails.getAuthorities());
        SecurityContextHolder.getContext().setAuthentication(auth);

        doFilterInternal.invoke(jwtAuthFilter, request, response, filterChain);

        var currentAuth = SecurityContextHolder.getContext().getAuthentication();
        assertThat(currentAuth).isEqualTo(auth);
        verify(jwtUtil, never()).getSubject(any());
        verify(userDetailsService, never()).loadUserByUsername(any());
        verify(filterChain).doFilter(request, response);
    }

    @Test
    void doFilterInternal_shouldLogWarningAndContinue_whenJwtThrowsException() throws Exception {
        String token = "invalid.token";
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.addHeader("Authorization", "Bearer " + token);
        MockHttpServletResponse response = new MockHttpServletResponse();
        when(jwtUtil.getSubject(token)).thenThrow(new RuntimeException("JWT is invalid"));

        doFilterInternal.invoke(jwtAuthFilter, request, response, filterChain);

        assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
        verify(filterChain).doFilter(request, response);
    }

    private String callResolveToken(HttpServletRequest request) throws Exception {
        return (String) resolveToken.invoke(jwtAuthFilter, request);
    }
}

package test.security;

import com.example.expensetracker.model.Role;
import com.example.expensetracker.security.JwtUtil;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.security.SignatureException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.test.util.ReflectionTestUtils;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static test.util.Constants.USER_EMAIL;

public class JwtUtilTest {

    private JwtUtil jwtUtil;

    @BeforeEach
    void setUp() {
        jwtUtil = new JwtUtil();
        ReflectionTestUtils.setField(jwtUtil, "secret", "super-secret-key-which-is-very-long-1234567890");
        ReflectionTestUtils.setField(jwtUtil, "accessExpiration", 1000L * 60);
        ReflectionTestUtils.setField(jwtUtil, "refreshExpiration", 1000L * 120);
    }

    @Test
    void generateAccessToken_shouldContainEmailAndRole() {
        String token = jwtUtil.generateAccessToken(USER_EMAIL, Role.USER);
        Jws<Claims> claimsJws = jwtUtil.parse(token);

        assertThat(claimsJws.getPayload().getSubject()).isEqualTo(USER_EMAIL);
        assertThat(claimsJws.getPayload().get("role")).isEqualTo("USER");
        assertThat(claimsJws.getPayload().get("jti")).isNotNull();
    }

    @Test
    void generateRefreshToken_shouldContainEmailAndNoRole() {
        String token = jwtUtil.generateRefreshToken(USER_EMAIL);
        Jws<Claims> claimsJws = jwtUtil.parse(token);

        assertThat(claimsJws.getPayload().getSubject()).isEqualTo(USER_EMAIL);
        assertThat(claimsJws.getPayload().get("role")).isNull();
        assertThat(claimsJws.getPayload().get("jti")).isNotNull();
    }

    @Test
    void getSubject_shouldReturnEmailFromToken() {
        String token = jwtUtil.generateAccessToken(USER_EMAIL, Role.USER);
        assertThat(jwtUtil.getSubject(token)).isEqualTo(USER_EMAIL);
    }

    @Test
    void parse_shouldThrow_whenTokenSignatureInvalid() {
        String token = jwtUtil.generateAccessToken(USER_EMAIL, Role.USER);
        String invalidToken = token + "tampered";

        assertThatThrownBy(() -> jwtUtil.parse(invalidToken)).isInstanceOf(SignatureException.class);
    }

    @Test
    void parse_shouldThrow_whenTokenExpired() {
        ReflectionTestUtils.setField(jwtUtil, "accessExpiration", -1L);
        String token = jwtUtil.generateAccessToken(USER_EMAIL, Role.USER);

        assertThatThrownBy(() -> jwtUtil.parse(token)).isInstanceOf(ExpiredJwtException.class);
    }

    @Test
    void generateAccessToken_shouldProduceDifferentTokens() {
        String accessToken1 = jwtUtil.generateAccessToken(USER_EMAIL, Role.USER);
        String accessToken2 = jwtUtil.generateAccessToken(USER_EMAIL, Role.USER);

        assertThat(accessToken1).isNotEqualTo(accessToken2);
    }
}

package test.security;

import org.springframework.security.test.context.support.WithSecurityContext;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

import static test.util.Constants.USER_EMAIL;

@Retention(RetentionPolicy.RUNTIME)
@WithSecurityContext(factory = WithMockCustomUserSecurityContextFactory.class)
public @interface WithMockCustomUser {
    String email() default USER_EMAIL;
    String[] roles() default {"USER"};
}

package test.security;

import com.example.expensetracker.details.UserDetailsImpl;
import com.example.expensetracker.model.Role;
import com.example.expensetracker.model.User;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.test.context.support.WithSecurityContextFactory;

import java.util.Arrays;
import java.util.stream.Collectors;

import static test.util.Constants.USER_PASSWORD;

public class WithMockCustomUserSecurityContextFactory implements WithSecurityContextFactory<WithMockCustomUser> {

    @Override
    public SecurityContext createSecurityContext(WithMockCustomUser customUser) {
        SecurityContext context = SecurityContextHolder.createEmptyContext();
        User user = User.builder()
                .email(customUser.email())
                .password(USER_PASSWORD)
                .roles(Arrays.stream(customUser.roles()).map(Role::valueOf).collect(Collectors.toSet()))
                .banned(false)
                .build();

        UserDetailsImpl userDetails = new UserDetailsImpl(user);

        UsernamePasswordAuthenticationToken auth =
                new UsernamePasswordAuthenticationToken(userDetails, USER_PASSWORD, userDetails.getAuthorities());

        context.setAuthentication(auth);
        return context;
    }
}

package test.util;

public final class Constants {
    public static final String ADMIN_EMAIL = "admin@example.com";
    public static final String MODERATOR_EMAIL = "moderator@example.com";
    public static final String USER_EMAIL = "user@example.com";

    public static final String USER_NAME = "User";
    public static final String USER_PASSWORD = "123";
    public static final String USER_PASSWORD_NEW = "12345";
    public static final String USER_PASSWORD_ENCODED = "encoded";

    public static final Long ID_INVALID = 99999L;
    public static final Long ID_VALID = 42L;
    public static final Long ID_ADMIN = 777L;
    public static final String ID_STRING = "42";
    public static final Long ID_EXPENSE = 80L;
    public static final Long ID_TRANSACTION = 50L;
    public static final Long ID_CATEGORY = 60L;

    public static final String API_TEST_ENDPOINT = "/api/test";
    public static final String API_AUTH_REGISTER = "/api/auth/register";
    public static final String API_AUTH_LOGIN = "/api/auth/login";
    public static final String API_AUTH_REFRESH = "/api/auth/refresh";
    public static final String API_ADMIN_USERS = "/api/admin/users";
    public static final String API_ADMIN_USERS_CREATE_MODERATOR = "/api/admin/users/create/moderator";
    public static final String API_ADMIN_USERS_CREATE_ADMINISTRATOR = "/api/admin/users/create/administrator";
    public static final String API_USERS_ME = "/api/users/me";
    public static final String API_USERS_CHANGE_PASSWORD = "/api/users/change-password";
    public static final String API_EXPENSES_REPORT = "/api/expenses/report";
    public static final String API_EXPENSES_TOTAL = "/api/expenses/total";
    public static final String API_EXPENSES_STATS_MONTHLY = "/api/expenses/stats/monthly";
    public static final String API_RECURRING_TRANSACTION = "/api/recurring-transaction";
    public static final String API_RECURRING_TRANSACTION_CREATE = "/api/recurring-transaction/create";
    public static final String API_MODERATOR_USERS = "/api/moderator/users";
    
    
    public static final String TYPE_ERROR_WARN = "WARN";
    public static final String TEST_MESSAGE = "Test message";
    public static final String LOGGER_TEST_DATA = "LoggerTestData";
    public static final String CATEGORY_NAME = "food";
    
    public static final String DESCRIPTION = "description";
    public static final int INTERVAL_DAYS = 30;
    public static final int AMOUNT = 500;
    public static final int AMOUNT_NEGATIVE = -500;

    public static final String TOKEN_ACCESS = "access token";
    public static final String TOKEN_REFRESH = "refresh token";

    private Constants() {
    }
}

package test.util;

import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.context.support.ResourceBundleMessageSource;

public final class TestMessageSource {

    private static final MessageSource messageSource = init();

    public TestMessageSource() {}

    private static MessageSource init() {
        ResourceBundleMessageSource ms = new ResourceBundleMessageSource();
        ms.setBasenames("ValidationMessages");
        ms.setDefaultEncoding("UTF-8");
        return ms;
    }
    
    public static String msg(String key) {
        return messageSource.getMessage(key, null, LocaleContextHolder.getLocale());
    }
}

package test.util;

import com.example.expensetracker.model.Role;
import com.example.expensetracker.model.User;
import com.example.expensetracker.repository.UserRepository;
import jakarta.validation.ConstraintViolation;
import org.springframework.mock.web.DelegatingServletOutputStream;

import java.io.ByteArrayOutputStream;
import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static test.util.Constants.USER_PASSWORD;

public final class TestUtils {

    private TestUtils() {
    }

    public static DelegatingServletOutputStream writeByteToStream(ByteArrayOutputStream outputStream) {
        return new DelegatingServletOutputStream(outputStream);
    }

    public static <T> void assertHasViolation(Set<ConstraintViolation<T>> violations,
                                              String field,
                                              String expectedMessage) {
        assertThat(violations)
                .as("–û–∂–∏–¥–∞–ª–∞—Å—å –æ—à–∏–±–∫–∞ –Ω–∞ –ø–æ–ª–µ '%s', —Å–æ–¥–µ—Ä–∂–∞—â–∞—è '%s'", field, expectedMessage)
                .anySatisfy(v -> {
                    assertThat(v.getPropertyPath().toString()).isEqualTo(field);
                    assertThat(v.getMessage()).containsIgnoringCase(expectedMessage);
                });

        boolean found = violations.stream()
                .anyMatch(v -> v.getPropertyPath().toString().equals(field)
                        && v.getMessage().toLowerCase().contains(expectedMessage.toLowerCase()));
        assertTrue(found, () -> String.format(
                "–û–∂–∏–¥–∞–ª–∞—Å—å –æ—à–∏–∫–∞ –Ω–∞ –ø–æ–ª–µ '%s', —Å–æ–¥–µ—Ä–∂–∞—â–∞—è '%s'. –ù–æ –∏–º–µ–µ–º: '%s'",
                field, expectedMessage, violations));
    }

    public static User createAndSaveUser(String mail, Role role, UserRepository userRepository) {
        User user = new User();
        user.setEmail(mail);
        user.setPassword(USER_PASSWORD);
        user.setBanned(false);
        user.setDeleted(false);
        user.getRoles().add(Role.USER);
        user.getRoles().add(role);
        return userRepository.save(user);
    }
}

spring:
  cache:
    type: none
  scheduler:
    recurring-cron: 0 0 1 * * *
  datasource:
    url: jdbc:postgresql://localhost:5432/expense_tracker
    driver-class-name: org.postgresql.Driver
    username: postgres
    password: postgres
  liquibase:
    enabled: true
    change-log: classpath:/db/changelog-master.xml
    drop-first: true
  jpa:
    hibernate:
      ddl-auto: none
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
  elasticsearch:
    uris: http://localhost:9200

<configuration>

    <!-- –§–∞–π–ª –¥–ª—è –∑–∞–ø–∏—Å–∏ –ª–æ–≥–æ–≤ -->
    <appender name="FILE" class="ch.qos.logback.core.FileAppender">
        <file>logs/test.log</file>
        <append>false</append> <!-- –ü–µ—Ä–µ–∑–∞–ø–∏—Å—å –ø—Ä–∏ –∫–∞–∂–¥–æ–º –∑–∞–ø—É—Å–∫–µ -->
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- –ö–æ–Ω—Å–æ–ª—å–Ω—ã–π –∞–ø–ø–µ–Ω–¥–µ—Ä -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- –¢–æ–ª—å–∫–æ –Ω–∞—à –ø—Ä–æ–µ–∫—Ç ‚Äî –∏ –≤ —Ñ–∞–π–ª, –∏ –≤ –∫–æ–Ω—Å–æ–ª—å -->
    <logger name="com.example" level="DEBUG" additivity="false">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
    </logger>

    <!-- –í—Å—ë –æ—Å—Ç–∞–ª—å–Ω–æ–µ ‚Äî —Ç–æ–ª—å–∫–æ –≤ —Ñ–∞–π–ª -->
    <root level="INFO">
        <appender-ref ref="FILE"/>
    </root>

</configuration>

org.springframework.test.context.TestExecutionListener=\
test.config.DatabaseCleanupListener

version: '3.9'
services:

  postgres:
    image: postgres:15
    container_name: expense_postgres
    environment:
      POSTGRES_DB: expense_tracker
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d expense_tracker"]
      interval: 5s
      timeout: 5s
      retries: 10
      start_period: 10s

  elasticsearch:
    image: elasticsearch:8.15.0
    container_name: expense_elastic
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
    ports:
      - "9200:9200"
    healthcheck:
      test: [ "CMD-SHELL", "curl -f http://localhost:9200/_cluster/health || exit 1" ]
      interval: 10s
      timeout: 10s
      retries: 20
      start_period: 20s

  kibana:
    image: kibana:8.15.0
    container_name: expense_kibana
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
    ports:
      - "5601:5601"
    depends_on:
      - elasticsearch

  expense-tracker:
    build: .
    container_name: expense_app
    environment:
      SPRING_PROFILES_ACTIVE: dev
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/expense_tracker
      SPRING_DATASOURCE_USERNAME: postgres
      SPRING_DATASOURCE_PASSWORD: postgres
      SPRING_ELASTICSEARCH_URIS: http://elasticsearch:9200
    ports:
      - "8080:8080"
    depends_on:
      postgres:
        condition: service_healthy
      elasticsearch:
        condition: service_healthy

volumes:
  postgres_data:


FROM eclipse-temurin:17-jdk
WORKDIR /app
COPY target/expense-tracker-0.0.1-SNAPSHOT.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]


<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.5</version>
        <relativePath/>
    </parent>

    <groupId>com.example</groupId>
    <artifactId>expense-tracker</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>expense-tracker</name>
    <description>Expense Tracker Application</description>

    <properties>
        <java.version>17</java.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <file.encoding>UTF-8</file.encoding>
        <gatling.version>3.10.4</gatling.version>
        <gatling.plugin.version>4.9.2</gatling.plugin.version>
    </properties>

    <repositories>
        <!-- –†–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π Gatling -->
        <repository>
            <id>gatling</id>
            <url>https://repo1.maven.org/maven2/</url>
        </repository>
        <repository>
            <id>gatling-bintray</id>
            <url>https://dl.bintray.com/gatling/maven</url>
        </repository>
    </repositories>

    <dependencies>
        <!-- Spring Boot -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-elasticsearch</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-cache</artifactId>
        </dependency>

        <!-- DB -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.liquibase</groupId>
            <artifactId>liquibase-core</artifactId>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.12.4</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.12.4</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.12.4</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-crypto</artifactId>
        </dependency>

        <!-- Utils -->
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>1.5.5.Final</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>3.18.0</version>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.datatype</groupId>
            <artifactId>jackson-datatype-jsr310</artifactId>
        </dependency>

        <!-- Swagger/OpenAPI -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>2.8.9</version>
        </dependency>

        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-core</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>nl.jqno.equalsverifier</groupId>
            <artifactId>equalsverifier</artifactId>
            <version>3.15.3</version>
            <scope>test</scope>
        </dependency>

        <!-- Cache -->
        <dependency>
            <groupId>com.github.ben-manes.caffeine</groupId>
            <artifactId>caffeine</artifactId>
            <version>3.1.8</version>
        </dependency>

        <!-- Core DSL -->
        <dependency>
            <groupId>io.gatling.highcharts</groupId>
            <artifactId>gatling-charts-highcharts</artifactId>
            <version>${gatling.version}</version>
            <scope>test</scope>
        </dependency>

        <!-- HTTP DSL -->
        <dependency>
            <groupId>io.gatling</groupId>
            <artifactId>gatling-http-java</artifactId>
            <version>${gatling.version}</version>
            <scope>test</scope>
        </dependency>

        <!-- Core Java DSL -->
        <dependency>
            <groupId>io.gatling</groupId>
            <artifactId>gatling-core-java</artifactId>
            <version>${gatling.version}</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- Compiler + MapStruct -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.13.0</version>
                <configuration>
                    <source>17</source>
                    <target>17</target>
                    <parameters>true</parameters>
                    <compilerArgs>
                        <arg>-parameters</arg>
                    </compilerArgs>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>1.5.5.Final</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>

            <!-- Jacoco -->
            <plugin>
                <groupId>org.jacoco</groupId>
                <artifactId>jacoco-maven-plugin</artifactId>
                <version>0.8.11</version>
                <executions>
                    <!-- Unit -->
                    <execution>
                        <id>prepare-agent</id>
                        <phase>initialize</phase>
                        <goals>
                            <goal>prepare-agent</goal>
                        </goals>
                        <configuration>
                            <destFile>${project.build.directory}/jacoco-unit.exec</destFile>
                            <propertyName>jacoco.unit.argLine</propertyName>
                        </configuration>
                    </execution>
                    <execution>
                        <id>report-unit</id>
                        <phase>test</phase>
                        <goals>
                            <goal>report</goal>
                        </goals>
                        <configuration>
                            <dataFile>${project.build.directory}/jacoco-unit.exec</dataFile>
                            <outputDirectory>${project.reporting.outputDirectory}/jacoco-unit</outputDirectory>
                        </configuration>
                    </execution>
                    <!-- Integrations -->
                    <execution>
                        <id>prepare-agent-integration</id>
                        <phase>pre-integration-test</phase>
                        <goals>
                            <goal>prepare-agent</goal>
                        </goals>
                        <configuration>
                            <destFile>${project.build.directory}/jacoco-it.exec</destFile>
                            <propertyName>jacoco.it.argLine</propertyName>
                        </configuration>
                    </execution>
                    <execution>
                        <id>report-integration</id>
                        <phase>verify</phase>
                        <goals>
                            <goal>report</goal>
                        </goals>
                        <configuration>
                            <dataFile>${project.build.directory}/jacoco-it.exec</dataFile>
                            <outputDirectory>${project.reporting.outputDirectory}/jacoco-it</outputDirectory>
                        </configuration>
                    </execution>
                </executions>
            </plugin>

            <!-- Surefire (unit) -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.1.2</version>
                <configuration>
                    <argLine>${jacoco.unit.argLine} -Dfile.encoding=UTF-8</argLine>
                </configuration>
            </plugin>

            <!-- Failsafe (integrations) -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-failsafe-plugin</artifactId>
                <version>3.1.2</version>
                <configuration>
                    <argLine>${jacoco.it.argLine} -Dfile.encoding=UTF-8</argLine>
                </configuration>
                <executions>
                    <execution>
                        <id>integration-tests</id>
                        <goals>
                            <goal>integration-test</goal>
                            <goal>verify</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>

            <!-- Spring Boot -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>

            <plugin>
                <groupId>io.gatling</groupId>
                <artifactId>gatling-maven-plugin</artifactId>
                <version>${gatling.plugin.version}</version>
                <configuration>
                    <simulationClass>simulations.ExpenseTrackerSimulation</simulationClass>
                </configuration>
                <executions>
                    <execution>
                        <id>gatling</id>
                        <phase>none</phase>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>


# Expense Tracker Application
Expense Tracker ‚Äî —ç—Ç–æ –ø–æ–ª–Ω–æ—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –¥–ª—è —É—á—ë—Ç–∞ —Ä–∞—Å—Ö–æ–¥–æ–≤ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —Ä–æ–ª–µ–π, JWT-–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–µ–π, –∞—É–¥–∏—Ç–æ–º –¥–µ–π—Å—Ç–≤–∏–π –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º.

## –û—Å–Ω–æ–≤–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏
- –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∏ –≤—Ö–æ–¥ –ø–æ JWT
- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏ (–±–∞–Ω, —Ä–∞–∑–±–∞–Ω, –ø–æ–≤—ã—à–µ–Ω–∏–µ/–ø–æ–Ω–∏–∂–µ–Ω–∏–µ —Ä–æ–ª–µ–π)
- –£—á—ë—Ç —Ä–∞—Å—Ö–æ–¥–æ–≤ –∏ –æ—Ç—á—ë—Ç—ã –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
- –ü–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ (Recurring)
- –ê—É–¥–∏—Ç –¥–µ–π—Å—Ç–≤–∏–π
- –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤ –∏ –æ—à–∏–±–æ–∫ (Elasticsearch)
- –õ–æ–∫–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π
- Swagger UI (OpenAPI) –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è


## –¢–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π —Å—Ç–µ–∫
Spring Boot 3.4, Spring Security, JWT, JPA (Hibernate), PostgreSQL, Liquibase, MapStruct, Elasticsearch, Docker, JUnit5, 
Mockito, Jacoco, Caffeine Cache, Gatling.


##  –ó–∞–ø—É—Å–∫
mvn clean package -DskipTests
docker-compose up --build
–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ –ø–æ –∞–¥—Ä–µ—Å—É: http://localhost:8080/swagger-ui/index.html


## Docker –æ–∫—Ä—É–∂–µ–Ω–∏–µ
–ü—Ä–æ–µ–∫—Ç –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω–æ —á–µ—Ä–µ–∑ Docker Compose.

## –°–µ—Ä–≤–∏—Å—ã:
- `postgres` ‚Äî –æ—Å–Ω–æ–≤–Ω–∞—è –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö (PostgreSQL 15)
- `elasticsearch` ‚Äî —Ö—Ä–∞–Ω–µ–Ω–∏–µ –ª–æ–≥–æ–≤ –∞—É–¥–∏—Ç–∞ (Elasticsearch 8.15.0)
- `kibana` ‚Äî –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∞—É–¥–∏—Ç–∞
- `expense-tracker` ‚Äî —Å–∞–º–æ Spring Boot –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ

## Jacoco coverage:
mvn clean verify ‚Üí –æ—Ç—á—ë—Ç –≤ target/site/jacoco/index.html

## –ö–æ–Ω—Ç–∞–∫—Ç—ã:
Telegram - @lex_teg
Discord - lamer1863


